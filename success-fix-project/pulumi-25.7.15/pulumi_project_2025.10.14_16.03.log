2025-10-14 16:02:29,109 - Logger initialized. Waiting for project name...
2025-10-14 16:03:13,030 - INFO - Flushed buffer. Live logging to file has started.
2025-10-14 16:03:13,030 - EVENT from author: 'initial_setup_agent'
  - STATE_UPDATE: {'basic_information': '{\n  "project_name": "pulumi",\n  "project_config_path": "/root/oss-fuzz/projects/pulumi",\n  "project_source_path": "/root/pulumi",\n  "max_depth": 0\n}'}
2025-10-14 16:03:17,188 - EVENT from author: 'run_fuzz_and_collect_log_agent'
  - TOOL_CALL: run_fuzz_build_streaming({'project_name': 'pulumi', 'oss_fuzz_path': '/root/oss-fuzz'})
2025-10-14 16:06:32,761 - EVENT from author: 'run_fuzz_and_collect_log_agent'
  - TOOL_RESPONSE for 'run_fuzz_build_streaming': {'status': 'error', 'message': "Fuzzing构建命令失败。详细日志已保存到 'fuzz_build_log_file/fuzz_build_log.txt'。"}
2025-10-14 16:06:36,691 - EVENT from author: 'run_fuzz_and_collect_log_agent'
  - STATE_UPDATE: {'fuzz_build_log': 'Fuzzing构建任务执行完毕。构建过程失败了，详细的错误日志已经保存到 `fuzz_build_log_file/fuzz_build_log.txt` 文件中。\n\n根据返回结果，构建命令执行失败。您可以通过查看日志文件来了解具体的错误信息，这将帮助您诊断和解决构建过程中遇到的问题。'}
2025-10-14 16:06:39,766 - EVENT from author: 'decision_agent'
  - TOOL_CALL: read_file_content({'file_path': 'fuzz_build_log_file/fuzz_build_log.txt'})
2025-10-14 16:06:39,768 - EVENT from author: 'decision_agent'
  - TOOL_RESPONSE for 'read_file_content': {'status': 'success', 'message': "文件 'fuzz_build_log_file/fuzz_build_log.txt' 的内容已成功读取并加载到内存中。", 'content': 'go: downloading github.com/lib/pq v1.10.9\ngo: downloading github.com/blang/semver v3.5.1+incompatible\ngo: downloading github.com/AlecAivazis/survey/v2 v2.3.7\ngo: downloading github.com/pulumi/esc v0.17.0\ngo: downloading golang.org/x/exp v0.0.0-20240719175910-8a7402abbf56\ngo: downloading github.com/Netflix/go-expect v0.0.0-20220104043353-73e0943537d2\ngo: downloading github.com/hexops/gotextdiff v1.0.3\ngo: downloading github.com/jonboulle/clockwork v0.4.0\ngo: downloading github.com/opentracing/opentracing-go v1.2.0\ngo: downloading github.com/pgavlin/diff v0.0.0-20230503175810-113847418e2e\ngo: downloading github.com/pkg/browser v0.0.0-20240102092130-5ac0b6a4141c\ngo: downloading github.com/segmentio/encoding v0.3.5\ngo: downloading github.com/dustin/go-humanize v1.0.1\ngo: downloading github.com/pgavlin/fx/v2 v2.0.10\ngo: downloading github.com/pgavlin/fx v0.1.6\ngo: downloading github.com/shirou/gopsutil/v3 v3.22.3\ngo: downloading github.com/spf13/cobra v1.10.1\ngo: downloading github.com/djherbis/times v1.5.0\ngo: downloading github.com/moby/term v0.0.0-20210619224110-3f7ff695adc6\ngo: downloading github.com/google/go-querystring v1.1.0\ngo: downloading github.com/gorilla/mux v1.8.0\ngo: downloading github.com/spf13/pflag v1.0.9\ngo: downloading go.uber.org/automaxprocs v1.6.0\ngo: downloading github.com/hashicorp/hcl/v2 v2.22.0\ngo: downloading github.com/spf13/afero v1.9.5\ngo: downloading github.com/hashicorp/hcl v1.0.0\ngo: downloading github.com/go-git/go-git/v5 v5.13.1\ngo: downloading github.com/charmbracelet/glamour v0.6.0\ngo: downloading github.com/erikgeiser/promptkit v0.9.0\ngo: downloading github.com/nbutton23/zxcvbn-go v0.0.0-20180912185939-ae427f1e4c1d\ngo: downloading github.com/acarl005/stripansi v0.0.0-20180116102854-5a71ef0e047d\ngo: downloading github.com/moby/moby v28.3.3+incompatible\ngo: downloading cloud.google.com/go/storage v1.39.1\ngo: downloading github.com/deckarep/golang-set/v2 v2.5.0\ngo: downloading go.pennock.tech/tabular v1.1.3\ngo: downloading golang.org/x/oauth2 v0.30.0\ngo: downloading golang.org/x/text v0.26.0\ngo: downloading cloud.google.com/go v0.112.1\ngo: downloading golang.org/x/mod v0.25.0\ngo: downloading github.com/sergi/go-diff v1.4.0\ngo: downloading gopkg.in/yaml.v2 v2.4.0\ngo: downloading github.com/kballard/go-shellquote v0.0.0-20180428030007-95032a82bc51\ngo: downloading github.com/google/shlex v0.0.0-20191202100458-e7afc7fbc510\ngo: downloading github.com/google/pprof v0.0.0-20230406165453-00490a63f317\ngo: downloading github.com/creack/pty v1.1.17\ngo: downloading github.com/pgavlin/goldmark v1.1.33-0.20200616210433-b5eb04559386\ngo: downloading github.com/hinshun/vt10x v0.0.0-20220301184237-5011da428d02\ngo: downloading github.com/pulumi/appdash v0.0.0-20231130102222-75f619a67231\ngo: downloading github.com/zclconf/go-cty v1.13.2\ngo: downloading google.golang.org/grpc v1.72.1\ngo: downloading go.opentelemetry.io/otel v1.36.0\ngo: downloading github.com/golang/glog v1.2.4\ngo: downloading github.com/iancoleman/strcase v0.2.0\ngo: downloading go.opentelemetry.io/otel/exporters/otlp/otlptrace/otlptracegrpc v1.36.0\ngo: downloading go.opentelemetry.io/otel/sdk v1.36.0\ngo: downloading go.opentelemetry.io/otel/trace v1.36.0\ngo: downloading github.com/davecgh/go-spew v1.1.1\ngo: downloading go.opentelemetry.io/otel/exporters/otlp/otlptrace v1.36.0\ngo: downloading github.com/pulumi/inflector v0.1.1\ngo: downloading github.com/BurntSushi/toml v1.2.1\ngo: downloading golang.org/x/sync v0.15.0\ngo: downloading github.com/edsrzf/mmap-go v1.1.0\ngo: downloading github.com/mxschmitt/golang-combinations v1.0.0\ngo: downloading github.com/mitchellh/copystructure v1.2.0\ngo: downloading github.com/fatih/color v1.16.0\ngo: downloading github.com/natefinch/atomic v1.0.1\ngo: downloading cloud.google.com/go/logging v1.9.0\ngo: downloading github.com/xeipuuv/gojsonschema v1.2.0\ngo: downloading github.com/aws/aws-sdk-go v1.50.36\ngo: downloading lukechampine.com/frand v1.4.2\ngo: downloading google.golang.org/protobuf v1.36.6\ngo: downloading github.com/go-test/deep v1.0.3\ngo: downloading github.com/google/uuid v1.6.0\ngo: downloading github.com/grpc-ecosystem/grpc-opentracing v0.0.0-20180507213350-8e809c8a8645\ngo: downloading github.com/santhosh-tekuri/jsonschema/v5 v5.0.0\ngo: downloading google.golang.org/api v0.169.0\ngo: downloading golang.org/x/net v0.41.0\ngo: downloading google.golang.org/genproto v0.0.0-20240311173647-c811ad7063a7\ngo: downloading github.com/google/go-github/v55 v55.0.0\ngo: downloading github.com/godbus/dbus/v5 v5.1.0\ngo: downloading gocloud.dev/secrets/hashivault v0.37.0\ngo: downloading golang.org/x/sys v0.33.0\ngo: downloading cloud.google.com/go/kms v1.15.7\ngo: downloading github.com/Azure/azure-sdk-for-go/sdk/azcore v1.17.0\ngo: downloading github.com/Azure/azure-sdk-for-go/sdk/azidentity v1.8.2\ngo: downloading github.com/Azure/azure-sdk-for-go/sdk/keyvault/azkeys v0.10.0\ngo: downloading github.com/aws/aws-sdk-go-v2 v1.26.1\ngo: downloading github.com/aws/aws-sdk-go-v2/config v1.27.11\ngo: downloading github.com/aws/aws-sdk-go-v2/service/iam v1.31.4\ngo: downloading github.com/aws/aws-sdk-go-v2/service/kms v1.30.1\ngo: downloading github.com/aws/aws-sdk-go-v2/service/sts v1.28.6\ngo: downloading github.com/rivo/uniseg v0.4.4\ngo: downloading golang.org/x/crypto v0.39.0\ngo: downloading github.com/charmbracelet/bubbles v0.16.1\ngo: downloading github.com/charmbracelet/bubbletea v0.25.0\ngo: downloading github.com/charmbracelet/lipgloss v0.7.1\ngo: downloading github.com/mitchellh/go-ps v1.0.0\ngo: downloading github.com/pkg/errors v0.9.1\ngo: downloading github.com/uber/jaeger-client-go v2.30.0+incompatible\ngo: downloading github.com/rogpeppe/go-internal v1.13.1\ngo: downloading github.com/cheggaaa/pb v1.0.29\ngo: downloading github.com/texttheater/golang-levenshtein v1.0.1\ngo: downloading github.com/pmezard/go-difflib v1.0.0\ngo: downloading github.com/hashicorp/errwrap v1.1.0\ngo: downloading go.opencensus.io v0.24.0\ngo: downloading github.com/Azure/azure-sdk-for-go/sdk/storage/azblob v1.3.1\ngo: downloading github.com/Azure/go-autorest/autorest/to v0.4.0\ngo: downloading github.com/Azure/go-autorest v14.2.0+incompatible\ngo: downloading github.com/google/wire v0.6.0\ngo: downloading cloud.google.com/go/compute/metadata v0.6.0\ngo: downloading cloud.google.com/go/iam v1.1.6\ngo: downloading github.com/googleapis/gax-go/v2 v2.12.2\ngo: downloading github.com/aws/aws-sdk-go-v2/feature/s3/manager v1.16.15\ngo: downloading github.com/aws/aws-sdk-go-v2/service/s3 v1.53.1\ngo: downloading github.com/aws/smithy-go v1.20.2\ngo: downloading github.com/kevinburke/ssh_config v1.2.0\ngo: downloading github.com/mgutz/ansi v0.0.0-20170206155736-9520e82c474b\ngo: downloading github.com/sabhiram/go-gitignore v0.0.0-20210923224102-525f6e181f06\ngo: downloading github.com/pgavlin/text v0.0.0-20240821195002-b51d0990e284\ngo: downloading github.com/inconshreveable/mousetrap v1.1.0\ngo: downloading github.com/yusufpapurcu/wmi v1.2.2\ngo: downloading github.com/agext/levenshtein v1.2.3\ngo: downloading github.com/apparentlymart/go-textseg/v15 v15.0.0\ngo: downloading github.com/mitchellh/go-wordwrap v1.0.1\ngo: downloading golang.org/x/tools v0.34.0\ngo: downloading dario.cat/mergo v1.0.0\ngo: downloading github.com/ProtonMail/go-crypto v1.1.3\ngo: downloading github.com/go-git/go-billy/v5 v5.6.1\ngo: downloading github.com/muesli/termenv v0.15.2\ngo: downloading gopkg.in/check.v1 v1.0.0-20201130134442-10cb98267c6c\ngo: downloading gotest.tools/v3 v3.0.2\ngo: downloading github.com/google/go-cmp v0.7.0\ngo: downloading github.com/go-git/go-git-fixtures/v4 v4.3.2-0.20231010084843-55a94097c399\ngo: downloading github.com/yuin/goldmark v1.5.2\ngo: downloading github.com/yuin/goldmark-emoji v1.0.1\ngo: downloading github.com/segmentio/asm v1.1.3\ngo: downloading github.com/cpuguy83/go-md2man/v2 v2.0.6\ngo: downloading github.com/alecthomas/chroma/v2 v2.13.0\ngo: downloading github.com/ccojocar/zxcvbn-go v1.0.1\ngo: downloading github.com/pgavlin/aho-corasick v0.5.1\ngo: downloading mvdan.cc/sh/v3 v3.7.0\ngo: downloading github.com/alecthomas/chroma v0.10.0\ngo: downloading github.com/mattn/go-isatty v0.0.20\ngo: downloading github.com/liquidgecka/testlib v0.0.0-20180123051607-561e6b271c63\ngo: downloading golang.org/x/xerrors v0.0.0-20231012003039-104605ab7028\ngo: downloading github.com/pkg/term v1.1.0\ngo: downloading github.com/zclconf/go-cty-debug v0.0.0-20240509010212-0d6042c53940\ngo: downloading github.com/gogo/protobuf v1.3.2\ngo: downloading github.com/sourcegraph/appdash-data v0.0.0-20151005221446-73f23eafcf67\ngo: downloading github.com/go-logr/logr v1.4.2\ngo: downloading go.uber.org/goleak v1.3.0\ngo: downloading go.opentelemetry.io/proto/otlp v1.6.0\ngo: downloading google.golang.org/genproto/googleapis/rpc v0.0.0-20250519155744-55703ea1f237\ngo: downloading cloud.google.com/go/longrunning v0.5.5\ngo: downloading google.golang.org/genproto/googleapis/api v0.0.0-20250519155744-55703ea1f237\ngo: downloading github.com/mitchellh/reflectwalk v1.0.2\ngo: downloading github.com/mattn/go-colorable v0.1.13\ngo: downloading github.com/xeipuuv/gojsonreference v0.0.0-20180127040603-bd5ef7bd5415\ngo: downloading github.com/aead/chacha20 v0.0.0-20180709150244-8b13a72661da\ngo: downloading github.com/hashicorp/vault/api v1.12.0\ngo: downloading github.com/Azure/azure-sdk-for-go/sdk/internal v1.10.0\ngo: downloading github.com/AzureAD/microsoft-authentication-library-for-go v1.3.3\ngo: downloading github.com/Azure/azure-sdk-for-go/sdk/azidentity/cache v0.3.2\ngo: downloading github.com/golang-jwt/jwt/v5 v5.2.2\ngo: downloading github.com/redis/go-redis/v9 v9.7.0\ngo: downloading github.com/Azure/azure-sdk-for-go/sdk/keyvault/internal v0.7.1\ngo: downloading github.com/aws/aws-sdk-go-v2/credentials v1.17.11\ngo: downloading github.com/aws/aws-sdk-go-v2/feature/ec2/imds v1.16.1\ngo: downloading github.com/aws/aws-sdk-go-v2/internal/ini v1.8.0\ngo: downloading github.com/aws/aws-sdk-go-v2/service/sso v1.20.5\ngo: downloading github.com/aws/aws-sdk-go-v2/service/ssooidc v1.23.4\ngo: downloading github.com/aws/aws-sdk-go-v2/internal/configsources v1.3.5\ngo: downloading github.com/aws/aws-sdk-go-v2/service/internal/accept-encoding v1.11.2\ngo: downloading github.com/aws/aws-sdk-go-v2/service/internal/presigned-url v1.11.7\ngo: downloading github.com/tgummerer/clipboard v0.0.0-20241001131231-d02d263e614e\ngo: downloading github.com/mattn/go-runewidth v0.0.15\ngo: downloading github.com/containerd/console v1.0.4-0.20230313162750-1ae8d489ac81\ngo: downloading github.com/mattn/go-localereader v0.0.1\ngo: downloading github.com/muesli/ansi v0.0.0-20230316100256-276c6243b2f6\ngo: downloading github.com/muesli/reflow v0.3.0\ngo: downloading github.com/opentracing/basictracer-go v1.1.0\ngo: downloading github.com/uber/jaeger-lib v2.4.1+incompatible\ngo: downloading go.uber.org/atomic v1.9.0\ngo: downloading github.com/google/go-replayers/grpcreplay v1.1.0\ngo: downloading github.com/google/go-replayers/httpreplay v1.2.0\ngo: downloading github.com/aws/aws-sdk-go-v2/aws/protocol/eventstream v1.6.2\ngo: downloading github.com/aws/aws-sdk-go-v2/internal/v4a v1.3.5\ngo: downloading github.com/aws/aws-sdk-go-v2/service/internal/checksum v1.3.7\ngo: downloading github.com/aws/aws-sdk-go-v2/service/internal/s3shared v1.17.5\ngo: downloading github.com/golang/groupcache v0.0.0-20210331224755-41bb18bfe9da\ngo: downloading github.com/elazarl/goproxy v1.2.3\ngo: downloading github.com/skeema/knownhosts v1.3.0\ngo: downloading github.com/xanzy/ssh-agent v0.3.3\ngo: downloading github.com/armon/go-socks5 v0.0.0-20160902184237-e75332964ef5\ngo: downloading github.com/gliderlabs/ssh v0.3.8\ngo: downloading github.com/tklauser/go-sysconf v0.3.10\ngo: downloading github.com/Azure/go-ansiterm v0.0.0-20210617225240-d185dfc1b5a1\ngo: downloading github.com/go-ole/go-ole v1.2.6\ngo: downloading github.com/prashantv/gostub v1.1.0\ngo: downloading github.com/cyphar/filepath-securejoin v0.3.6\ngo: downloading github.com/onsi/gomega v1.34.1\ngo: downloading github.com/go-git/gcfg v1.5.1-0.20230307220236-3a3c6141e376\ngo: downloading github.com/pjbgf/sha1cd v0.3.0\ngo: downloading github.com/emirpasic/gods v1.18.1\ngo: downloading github.com/jbenet/go-context v0.0.0-20150711004518-d14ea06fba99\ngo: downloading github.com/microcosm-cc/bluemonday v1.0.21\ngo: downloading github.com/olekukonko/tablewriter v0.0.5\ngo: downloading github.com/aymanbagabas/go-osc52/v2 v2.0.1\ngo: downloading github.com/lucasb-eyer/go-colorful v1.2.0\ngo: downloading github.com/kr/pretty v0.3.1\ngo: downloading github.com/russross/blackfriday/v2 v2.1.0\ngo: downloading go.opentelemetry.io/contrib/instrumentation/net/http/otelhttp v0.49.0\ngo: downloading github.com/golang/protobuf v1.5.4\ngo: downloading github.com/apparentlymart/go-textseg/v13 v13.0.0\ngo: downloading go.opentelemetry.io/otel/metric v1.36.0\ngo: downloading github.com/go-logr/stdr v1.2.2\ngo: downloading go.opentelemetry.io/auto/sdk v1.1.0\ngo: downloading github.com/cenkalti/backoff/v5 v5.0.2\ngo: downloading github.com/shurcooL/vfsgen v0.0.0-20200824052919-0d455de96546\ngo: downloading github.com/grpc-ecosystem/grpc-gateway/v2 v2.26.3\ngo: downloading go.opentelemetry.io/contrib/instrumentation/google.golang.org/grpc/otelgrpc v0.49.0\ngo: downloading golang.org/x/time v0.5.0\ngo: downloading github.com/jmespath/go-jmespath v0.4.0\ngo: downloading github.com/xeipuuv/gojsonpointer v0.0.0-20180127040702-4e3ac2762d5f\ngo: downloading github.com/cenkalti/backoff/v3 v3.2.2\ngo: downloading github.com/go-jose/go-jose/v3 v3.0.4\ngo: downloading github.com/hashicorp/go-cleanhttp v0.5.2\ngo: downloading github.com/hashicorp/go-retryablehttp v0.7.7\ngo: downloading github.com/hashicorp/go-rootcerts v1.0.2\ngo: downloading github.com/hashicorp/go-secure-stdlib/parseutil v0.1.8\ngo: downloading github.com/hashicorp/go-secure-stdlib/strutil v0.1.2\ngo: downloading github.com/hashicorp/go-hclog v1.6.3\ngo: downloading github.com/mitchellh/mapstructure v1.5.0\ngo: downloading github.com/kylelemons/godebug v1.1.0\ngo: downloading github.com/AzureAD/microsoft-authentication-extensions-for-go/cache v0.1.1\ngo: downloading github.com/cespare/xxhash/v2 v2.3.0\ngo: downloading github.com/dgryski/go-rendezvous v0.0.0-20200823014737-9f7001d12a5f\ngo: downloading github.com/aws/aws-sdk-go-v2/internal/endpoints/v2 v2.6.5\ngo: downloading github.com/Azure/azure-sdk-for-go/sdk/resourcemanager/storage/armstorage v1.5.0\ngo: downloading github.com/google/s2a-go v0.1.7\ngo: downloading github.com/HdrHistogram/hdrhistogram-go v1.1.2\ngo: downloading github.com/Microsoft/go-winio v0.6.1\ngo: downloading github.com/lufia/plan9stats v0.0.0-20211012122336-39d0f177ccd0\ngo: downloading github.com/power-devops/perfstat v0.0.0-20210106213030-5aafc221ea8c\ngo: downloading github.com/tklauser/numcpus v0.4.0\ngo: downloading github.com/cloudflare/circl v1.6.1\ngo: downloading github.com/anmitsu/go-shlex v0.0.0-20200514113438-38f4b401e2be\ngo: downloading gopkg.in/warnings.v0 v0.1.2\ngo: downloading github.com/dlclark/regexp2 v1.11.0\ngo: downloading github.com/aymerick/douceur v0.2.0\ngo: downloading github.com/alecthomas/assert/v2 v2.6.0\ngo: downloading github.com/googleapis/enterprise-certificate-proxy v0.3.2\ngo: downloading github.com/google/martian/v3 v3.3.2\ngo: downloading github.com/google/martian v2.1.0+incompatible\ngo: downloading github.com/alecthomas/repr v0.4.0\ngo: downloading go.opentelemetry.io/otel/sdk/metric v1.34.0\ngo: downloading github.com/felixge/httpsnoop v1.0.4\ngo: downloading github.com/kr/text v0.2.0\ngo: downloading github.com/shurcooL/httpfs v0.0.0-20190707220628-8d4bc4ba7749\ngo: downloading github.com/jmespath/go-jmespath/internal/testify v1.5.1\ngo: downloading github.com/mitchellh/go-homedir v1.1.0\ngo: downloading github.com/hashicorp/go-sockaddr v1.0.6\ngo: downloading github.com/ryanuber/go-glob v1.0.0\ngo: downloading github.com/keybase/go-keychain v0.0.0-20231219164618-57a3676c3af6\ngo: downloading github.com/stretchr/objx v0.5.2\ngo: downloading github.com/gorilla/css v1.0.0\ngo: finding module for package github.com/AdaLogics/go-fuzz-headers\ngo: downloading github.com/AdaLogics/go-fuzz-headers v0.0.0-20240806141605-e8a1dd7889d6\ngo: found github.com/AdaLogics/go-fuzz-headers in github.com/AdaLogics/go-fuzz-headers v0.0.0-20240806141605-e8a1dd7889d6\n+ compile_go_fuzzer github.com/pulumi/pulumi/pkg/v3/codegen/schema SchemaFuzzer schema_fuzzer\n/usr/local/bin/compile_go_fuzzer: line 32: cd: /root/go/src/github.com/pulumi/pulumi/pkg/v3/codegen/schema: No such file or directory\ngithub.com/pulumi/pulumi/pkg/v3/codegen/schema\ngithub.com/pulumi/pulumi/pkg/v3/codegen/schema\nRunning go-fuzz -tags gofuzz -func SchemaFuzzer -o schema_fuzzer.a github.com/pulumi/pulumi/pkg/v3/codegen/schema\n# github.com/pulumi/pulumi/pkg/v3/codegen/schema\ncodegen/schema/schema_fuzzer.go:29:29: not enough arguments in call to ImportSpec\n\thave (PackageSpec, nil)\n\twant (PackageSpec, map[string]Language, ValidationOptions)\n2025/10/14 08:06:30 failed to build packages:exit status 1\nERROR:__main__:Building fuzzers failed.\n'}
2025-10-14 16:06:48,121 - EVENT from author: 'decision_agent'
2025-10-14 16:06:53,571 - EVENT from author: 'prompt_generate_agent'
  - TOOL_CALL: prompt_generate_tool({'project_main_folder_path': '/root/pulumi', 'config_folder_path': '/root/oss-fuzz/projects/pulumi', 'max_depth': 0})
2025-10-14 16:06:53,574 - EVENT from author: 'prompt_generate_agent'
  - TOOL_RESPONSE for 'prompt_generate_tool': {'status': 'success', 'message': "Prompt生成工作流成功完成。初始上下文信息已整合到 'generated_prompt_file/prompt.txt' 文件中。其中包含了项目前'0'层的文件结构。请分析现有信息，如果需要深入了解特定目录，请使用 'find_and_append_file_details' 工具进行精确查找。"}
2025-10-14 16:06:56,096 - EVENT from author: 'prompt_generate_agent'
  - TOOL_CALL: read_file_content({'file_path': 'generated_prompt_file/prompt.txt'})
2025-10-14 16:06:56,099 - EVENT from author: 'prompt_generate_agent'
  - TOOL_RESPONSE for 'read_file_content': {'status': 'success', 'message': "文件 'generated_prompt_file/prompt.txt' 的内容已成功读取并加载到内存中。", 'content': '\n    你是软件测试方面首屈一指的专家，尤其擅长fuzz编译和构建问题的解决。通常是由fuzz配置文件与项目的文件内容不匹配导致的编译或构建问题。下面我将给你提供不同项目在oss-fuzz编译过程中的报错，请你根据报错信息和配置文件内容等信息对报错给出针对 性的解决方案，尽可能的不去改动与问题不相关的文件内容，最终使该项目能够成功的进行编译和build。\n    下面将给出pulumi的Dockerfile、build.sh、config_fuzzer.go、project.yaml、schema_fuzzer.go、文件树、报错日志内容。请你对文件树进行读取并分析给出的信息并且指出问题可能是由哪些文件内容引起的，是fuzz测试构建的核心文件如Dockerfile、build.sh或者是pulumi项目中的文件，并尝试给 出解决方案。\n\n\n--- Configuration Files ---\n\n### 内容来源: Dockerfile ###\n# Copyright 2021 Google LLC\n#\n# Licensed under the Apache License, Version 2.0 (the "License");\n# you may not use this file except in compliance with the License.\n# You may obtain a copy of the License at\n#\n#      http://www.apache.org/licenses/LICENSE-2.0\n#\n# Unless required by applicable law or agreed to in writing, software\n# distributed under the License is distributed on an "AS IS" BASIS,\n# WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n# See the License for the specific language governing permissions and\n# limitations under the License.\n#\n################################################################################\n\nFROM gcr.io/oss-fuzz-base/base-builder-go\nRUN git clone --depth 1 https://github.com/pulumi/pulumi\nCOPY build.sh \\\n\t config_fuzzer.go \\\n\t schema_fuzzer.go \\\n\t $SRC/\nWORKDIR $SRC/pulumi\n\n### 内容来源: build.sh ###\n#!/bin/bash -eu\n# Copyright 2021 Google LLC\n#\n# Licensed under the Apache License, Version 2.0 (the "License");\n# you may not use this file except in compliance with the License.\n# You may obtain a copy of the License at\n#\n#      http://www.apache.org/licenses/LICENSE-2.0\n#\n# Unless required by applicable law or agreed to in writing, software\n# distributed under the License is distributed on an "AS IS" BASIS,\n# WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n# See the License for the specific language governing permissions and\n# limitations under the License.\n#\n################################################################################\n\ncd pkg\ncp $SRC/schema_fuzzer.go $SRC/pulumi/pkg/codegen/schema/ \ncp $SRC/config_fuzzer.go $SRC/pulumi/sdk/go/common/resource/config/\ngo mod tidy\n\ncompile_go_fuzzer github.com/pulumi/pulumi/pkg/v3/codegen/schema SchemaFuzzer schema_fuzzer\ncompile_go_fuzzer github.com/pulumi/pulumi/sdk/v3/go/common/resource/config FuzzConfig fuzz\ncompile_go_fuzzer github.com/pulumi/pulumi/sdk/v3/go/common/resource/config FuzzParseKey fuzz_parse_key\n\n### 内容来源: config_fuzzer.go ###\n// Copyright 2021 Google LLC\n//\n// Licensed under the Apache License, Version 2.0 (the "License");\n// you may not use this file except in compliance with the License.\n// You may obtain a copy of the License at\n//\n//      http://www.apache.org/licenses/LICENSE-2.0\n//\n// Unless required by applicable law or agreed to in writing, software\n// distributed under the License is distributed on an "AS IS" BASIS,\n// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n// See the License for the specific language governing permissions and\n// limitations under the License.\n//\n\npackage config\n\nimport (\n\t"context"\n\t"encoding/json"\n)\n\nfunc FuzzConfig(data []byte) int {\n\tif len(data) != 32 {\n\t\treturn -1\n\t}\n\tcrypter := NewSymmetricCrypter(make([]byte, 32))\n\t_, _ = crypter.EncryptValue(context.Background(), string(data))\n\t_, _ = crypter.DecryptValue(context.Background(), string(data))\n\treturn 1\n}\n\nfunc fuuzRoundtripKey(m Key, marshal func(v interface{}) ([]byte, error),\n\tunmarshal func([]byte, interface{}) error) (Key, error) {\n\tb, err := marshal(m)\n\tif err != nil {\n\t\treturn Key{}, err\n\t}\n\n\tvar newM Key\n\terr = unmarshal(b, &newM)\n\treturn newM, err\n}\n\nfunc FuzzParseKey(data []byte) int {\n\tk, err := ParseKey(string(data))\n\tif err != nil {\n\t\treturn 0\n\t}\n\tfuuzRoundtripKey(k, json.Marshal, json.Unmarshal)\n\treturn 1\n}\n\n### 内容来源: project.yaml ###\nhomepage: "https://www.pulumi.com/"\nmain_repo: "https://github.com/pulumi/pulumi"\nprimary_contact: "anton@pulumi.com"\nauto_ccs :\n  - "adam@adalogics.com"\nlanguage: go\nfuzzing_engines:\n  - libfuzzer\nsanitizers:\n  - address\n\n### 内容来源: schema_fuzzer.go ###\n// Copyright 2021 Google LLC\n//\n// Licensed under the Apache License, Version 2.0 (the "License");\n// you may not use this file except in compliance with the License.\n// You may obtain a copy of the License at\n//\n//      http://www.apache.org/licenses/LICENSE-2.0\n//\n// Unless required by applicable law or agreed to in writing, software\n// distributed under the License is distributed on an "AS IS" BASIS,\n// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n// See the License for the specific language governing permissions and\n// limitations under the License.\n//\n\npackage schema\n\nimport (\n\tfuzz "github.com/AdaLogics/go-fuzz-headers"\n)\n\nfunc SchemaFuzzer(data []byte) int {\n\tpkgSpec := PackageSpec{}\n\tf := fuzz.NewConsumer(data)\n\terr := f.GenerateStruct(&pkgSpec)\n\tif err != nil {\n\t\treturn 0\n\t}\n\t_, _ = ImportSpec(pkgSpec, nil)\n\treturn 1\n}\n\n\n--- Project File Tree (Shallow View) ---\n📁 pulumi\n\n--- Fuzz Build Log ---\ngo: downloading github.com/lib/pq v1.10.9\ngo: downloading github.com/blang/semver v3.5.1+incompatible\ngo: downloading github.com/AlecAivazis/survey/v2 v2.3.7\ngo: downloading github.com/pulumi/esc v0.17.0\ngo: downloading golang.org/x/exp v0.0.0-20240719175910-8a7402abbf56\ngo: downloading github.com/Netflix/go-expect v0.0.0-20220104043353-73e0943537d2\ngo: downloading github.com/hexops/gotextdiff v1.0.3\ngo: downloading github.com/jonboulle/clockwork v0.4.0\ngo: downloading github.com/opentracing/opentracing-go v1.2.0\ngo: downloading github.com/pgavlin/diff v0.0.0-20230503175810-113847418e2e\ngo: downloading github.com/pkg/browser v0.0.0-20240102092130-5ac0b6a4141c\ngo: downloading github.com/segmentio/encoding v0.3.5\ngo: downloading github.com/dustin/go-humanize v1.0.1\ngo: downloading github.com/pgavlin/fx/v2 v2.0.10\ngo: downloading github.com/pgavlin/fx v0.1.6\ngo: downloading github.com/shirou/gopsutil/v3 v3.22.3\ngo: downloading github.com/spf13/cobra v1.10.1\ngo: downloading github.com/djherbis/times v1.5.0\ngo: downloading github.com/moby/term v0.0.0-20210619224110-3f7ff695adc6\ngo: downloading github.com/google/go-querystring v1.1.0\ngo: downloading github.com/gorilla/mux v1.8.0\ngo: downloading github.com/spf13/pflag v1.0.9\ngo: downloading go.uber.org/automaxprocs v1.6.0\ngo: downloading github.com/hashicorp/hcl/v2 v2.22.0\ngo: downloading github.com/spf13/afero v1.9.5\ngo: downloading github.com/hashicorp/hcl v1.0.0\ngo: downloading github.com/go-git/go-git/v5 v5.13.1\ngo: downloading github.com/charmbracelet/glamour v0.6.0\ngo: downloading github.com/erikgeiser/promptkit v0.9.0\ngo: downloading github.com/nbutton23/zxcvbn-go v0.0.0-20180912185939-ae427f1e4c1d\ngo: downloading github.com/acarl005/stripansi v0.0.0-20180116102854-5a71ef0e047d\ngo: downloading github.com/moby/moby v28.3.3+incompatible\ngo: downloading cloud.google.com/go/storage v1.39.1\ngo: downloading github.com/deckarep/golang-set/v2 v2.5.0\ngo: downloading go.pennock.tech/tabular v1.1.3\ngo: downloading golang.org/x/oauth2 v0.30.0\ngo: downloading golang.org/x/text v0.26.0\ngo: downloading cloud.google.com/go v0.112.1\ngo: downloading golang.org/x/mod v0.25.0\ngo: downloading github.com/sergi/go-diff v1.4.0\ngo: downloading gopkg.in/yaml.v2 v2.4.0\ngo: downloading github.com/kballard/go-shellquote v0.0.0-20180428030007-95032a82bc51\ngo: downloading github.com/google/shlex v0.0.0-20191202100458-e7afc7fbc510\ngo: downloading github.com/google/pprof v0.0.0-20230406165453-00490a63f317\ngo: downloading github.com/creack/pty v1.1.17\ngo: downloading github.com/pgavlin/goldmark v1.1.33-0.20200616210433-b5eb04559386\ngo: downloading github.com/hinshun/vt10x v0.0.0-20220301184237-5011da428d02\ngo: downloading github.com/pulumi/appdash v0.0.0-20231130102222-75f619a67231\ngo: downloading github.com/zclconf/go-cty v1.13.2\ngo: downloading google.golang.org/grpc v1.72.1\ngo: downloading go.opentelemetry.io/otel v1.36.0\ngo: downloading github.com/golang/glog v1.2.4\ngo: downloading github.com/iancoleman/strcase v0.2.0\ngo: downloading go.opentelemetry.io/otel/exporters/otlp/otlptrace/otlptracegrpc v1.36.0\ngo: downloading go.opentelemetry.io/otel/sdk v1.36.0\ngo: downloading go.opentelemetry.io/otel/trace v1.36.0\ngo: downloading github.com/davecgh/go-spew v1.1.1\ngo: downloading go.opentelemetry.io/otel/exporters/otlp/otlptrace v1.36.0\ngo: downloading github.com/pulumi/inflector v0.1.1\ngo: downloading github.com/BurntSushi/toml v1.2.1\ngo: downloading golang.org/x/sync v0.15.0\ngo: downloading github.com/edsrzf/mmap-go v1.1.0\ngo: downloading github.com/mxschmitt/golang-combinations v1.0.0\ngo: downloading github.com/mitchellh/copystructure v1.2.0\ngo: downloading github.com/fatih/color v1.16.0\ngo: downloading github.com/natefinch/atomic v1.0.1\ngo: downloading cloud.google.com/go/logging v1.9.0\ngo: downloading github.com/xeipuuv/gojsonschema v1.2.0\ngo: downloading github.com/aws/aws-sdk-go v1.50.36\ngo: downloading lukechampine.com/frand v1.4.2\ngo: downloading google.golang.org/protobuf v1.36.6\ngo: downloading github.com/go-test/deep v1.0.3\ngo: downloading github.com/google/uuid v1.6.0\ngo: downloading github.com/grpc-ecosystem/grpc-opentracing v0.0.0-20180507213350-8e809c8a8645\ngo: downloading github.com/santhosh-tekuri/jsonschema/v5 v5.0.0\ngo: downloading google.golang.org/api v0.169.0\ngo: downloading golang.org/x/net v0.41.0\ngo: downloading google.golang.org/genproto v0.0.0-20240311173647-c811ad7063a7\ngo: downloading github.com/google/go-github/v55 v55.0.0\ngo: downloading github.com/godbus/dbus/v5 v5.1.0\ngo: downloading gocloud.dev/secrets/hashivault v0.37.0\ngo: downloading golang.org/x/sys v0.33.0\ngo: downloading cloud.google.com/go/kms v1.15.7\ngo: downloading github.com/Azure/azure-sdk-for-go/sdk/azcore v1.17.0\ngo: downloading github.com/Azure/azure-sdk-for-go/sdk/azidentity v1.8.2\ngo: downloading github.com/Azure/azure-sdk-for-go/sdk/keyvault/azkeys v0.10.0\ngo: downloading github.com/aws/aws-sdk-go-v2 v1.26.1\ngo: downloading github.com/aws/aws-sdk-go-v2/config v1.27.11\ngo: downloading github.com/aws/aws-sdk-go-v2/service/iam v1.31.4\ngo: downloading github.com/aws/aws-sdk-go-v2/service/kms v1.30.1\ngo: downloading github.com/aws/aws-sdk-go-v2/service/sts v1.28.6\ngo: downloading github.com/rivo/uniseg v0.4.4\ngo: downloading golang.org/x/crypto v0.39.0\ngo: downloading github.com/charmbracelet/bubbles v0.16.1\ngo: downloading github.com/charmbracelet/bubbletea v0.25.0\ngo: downloading github.com/charmbracelet/lipgloss v0.7.1\ngo: downloading github.com/mitchellh/go-ps v1.0.0\ngo: downloading github.com/pkg/errors v0.9.1\ngo: downloading github.com/uber/jaeger-client-go v2.30.0+incompatible\ngo: downloading github.com/rogpeppe/go-internal v1.13.1\ngo: downloading github.com/cheggaaa/pb v1.0.29\ngo: downloading github.com/texttheater/golang-levenshtein v1.0.1\ngo: downloading github.com/pmezard/go-difflib v1.0.0\ngo: downloading github.com/hashicorp/errwrap v1.1.0\ngo: downloading go.opencensus.io v0.24.0\ngo: downloading github.com/Azure/azure-sdk-for-go/sdk/storage/azblob v1.3.1\ngo: downloading github.com/Azure/go-autorest/autorest/to v0.4.0\ngo: downloading github.com/Azure/go-autorest v14.2.0+incompatible\ngo: downloading github.com/google/wire v0.6.0\ngo: downloading cloud.google.com/go/compute/metadata v0.6.0\ngo: downloading cloud.google.com/go/iam v1.1.6\ngo: downloading github.com/googleapis/gax-go/v2 v2.12.2\ngo: downloading github.com/aws/aws-sdk-go-v2/feature/s3/manager v1.16.15\ngo: downloading github.com/aws/aws-sdk-go-v2/service/s3 v1.53.1\ngo: downloading github.com/aws/smithy-go v1.20.2\ngo: downloading github.com/kevinburke/ssh_config v1.2.0\ngo: downloading github.com/mgutz/ansi v0.0.0-20170206155736-9520e82c474b\ngo: downloading github.com/sabhiram/go-gitignore v0.0.0-20210923224102-525f6e181f06\ngo: downloading github.com/pgavlin/text v0.0.0-20240821195002-b51d0990e284\ngo: downloading github.com/inconshreveable/mousetrap v1.1.0\ngo: downloading github.com/yusufpapurcu/wmi v1.2.2\ngo: downloading github.com/agext/levenshtein v1.2.3\ngo: downloading github.com/apparentlymart/go-textseg/v15 v15.0.0\ngo: downloading github.com/mitchellh/go-wordwrap v1.0.1\ngo: downloading golang.org/x/tools v0.34.0\ngo: downloading dario.cat/mergo v1.0.0\ngo: downloading github.com/ProtonMail/go-crypto v1.1.3\ngo: downloading github.com/go-git/go-billy/v5 v5.6.1\ngo: downloading github.com/muesli/termenv v0.15.2\ngo: downloading gopkg.in/check.v1 v1.0.0-20201130134442-10cb98267c6c\ngo: downloading gotest.tools/v3 v3.0.2\ngo: downloading github.com/google/go-cmp v0.7.0\ngo: downloading github.com/go-git/go-git-fixtures/v4 v4.3.2-0.20231010084843-55a94097c399\ngo: downloading github.com/yuin/goldmark v1.5.2\ngo: downloading github.com/yuin/goldmark-emoji v1.0.1\ngo: downloading github.com/segmentio/asm v1.1.3\ngo: downloading github.com/cpuguy83/go-md2man/v2 v2.0.6\ngo: downloading github.com/alecthomas/chroma/v2 v2.13.0\ngo: downloading github.com/ccojocar/zxcvbn-go v1.0.1\ngo: downloading github.com/pgavlin/aho-corasick v0.5.1\ngo: downloading mvdan.cc/sh/v3 v3.7.0\ngo: downloading github.com/alecthomas/chroma v0.10.0\ngo: downloading github.com/mattn/go-isatty v0.0.20\ngo: downloading github.com/liquidgecka/testlib v0.0.0-20180123051607-561e6b271c63\ngo: downloading golang.org/x/xerrors v0.0.0-20231012003039-104605ab7028\ngo: downloading github.com/pkg/term v1.1.0\ngo: downloading github.com/zclconf/go-cty-debug v0.0.0-20240509010212-0d6042c53940\ngo: downloading github.com/gogo/protobuf v1.3.2\ngo: downloading github.com/sourcegraph/appdash-data v0.0.0-20151005221446-73f23eafcf67\ngo: downloading github.com/go-logr/logr v1.4.2\ngo: downloading go.uber.org/goleak v1.3.0\ngo: downloading go.opentelemetry.io/proto/otlp v1.6.0\ngo: downloading google.golang.org/genproto/googleapis/rpc v0.0.0-20250519155744-55703ea1f237\ngo: downloading cloud.google.com/go/longrunning v0.5.5\ngo: downloading google.golang.org/genproto/googleapis/api v0.0.0-20250519155744-55703ea1f237\ngo: downloading github.com/mitchellh/reflectwalk v1.0.2\ngo: downloading github.com/mattn/go-colorable v0.1.13\ngo: downloading github.com/xeipuuv/gojsonreference v0.0.0-20180127040603-bd5ef7bd5415\ngo: downloading github.com/aead/chacha20 v0.0.0-20180709150244-8b13a72661da\ngo: downloading github.com/hashicorp/vault/api v1.12.0\ngo: downloading github.com/Azure/azure-sdk-for-go/sdk/internal v1.10.0\ngo: downloading github.com/AzureAD/microsoft-authentication-library-for-go v1.3.3\ngo: downloading github.com/Azure/azure-sdk-for-go/sdk/azidentity/cache v0.3.2\ngo: downloading github.com/golang-jwt/jwt/v5 v5.2.2\ngo: downloading github.com/redis/go-redis/v9 v9.7.0\ngo: downloading github.com/Azure/azure-sdk-for-go/sdk/keyvault/internal v0.7.1\ngo: downloading github.com/aws/aws-sdk-go-v2/credentials v1.17.11\ngo: downloading github.com/aws/aws-sdk-go-v2/feature/ec2/imds v1.16.1\ngo: downloading github.com/aws/aws-sdk-go-v2/internal/ini v1.8.0\ngo: downloading github.com/aws/aws-sdk-go-v2/service/sso v1.20.5\ngo: downloading github.com/aws/aws-sdk-go-v2/service/ssooidc v1.23.4\ngo: downloading github.com/aws/aws-sdk-go-v2/internal/configsources v1.3.5\ngo: downloading github.com/aws/aws-sdk-go-v2/service/internal/accept-encoding v1.11.2\ngo: downloading github.com/aws/aws-sdk-go-v2/service/internal/presigned-url v1.11.7\ngo: downloading github.com/tgummerer/clipboard v0.0.0-20241001131231-d02d263e614e\ngo: downloading github.com/mattn/go-runewidth v0.0.15\ngo: downloading github.com/containerd/console v1.0.4-0.20230313162750-1ae8d489ac81\ngo: downloading github.com/mattn/go-localereader v0.0.1\ngo: downloading github.com/muesli/ansi v0.0.0-20230316100256-276c6243b2f6\ngo: downloading github.com/muesli/reflow v0.3.0\ngo: downloading github.com/opentracing/basictracer-go v1.1.0\ngo: downloading github.com/uber/jaeger-lib v2.4.1+incompatible\ngo: downloading go.uber.org/atomic v1.9.0\ngo: downloading github.com/google/go-replayers/grpcreplay v1.1.0\ngo: downloading github.com/google/go-replayers/httpreplay v1.2.0\ngo: downloading github.com/aws/aws-sdk-go-v2/aws/protocol/eventstream v1.6.2\ngo: downloading github.com/aws/aws-sdk-go-v2/internal/v4a v1.3.5\ngo: downloading github.com/aws/aws-sdk-go-v2/service/internal/checksum v1.3.7\ngo: downloading github.com/aws/aws-sdk-go-v2/service/internal/s3shared v1.17.5\ngo: downloading github.com/golang/groupcache v0.0.0-20210331224755-41bb18bfe9da\ngo: downloading github.com/elazarl/goproxy v1.2.3\ngo: downloading github.com/skeema/knownhosts v1.3.0\ngo: downloading github.com/xanzy/ssh-agent v0.3.3\ngo: downloading github.com/armon/go-socks5 v0.0.0-20160902184237-e75332964ef5\ngo: downloading github.com/gliderlabs/ssh v0.3.8\ngo: downloading github.com/tklauser/go-sysconf v0.3.10\ngo: downloading github.com/Azure/go-ansiterm v0.0.0-20210617225240-d185dfc1b5a1\ngo: downloading github.com/go-ole/go-ole v1.2.6\ngo: downloading github.com/prashantv/gostub v1.1.0\ngo: downloading github.com/cyphar/filepath-securejoin v0.3.6\ngo: downloading github.com/onsi/gomega v1.34.1\ngo: downloading github.com/go-git/gcfg v1.5.1-0.20230307220236-3a3c6141e376\ngo: downloading github.com/pjbgf/sha1cd v0.3.0\ngo: downloading github.com/emirpasic/gods v1.18.1\ngo: downloading github.com/jbenet/go-context v0.0.0-20150711004518-d14ea06fba99\ngo: downloading github.com/microcosm-cc/bluemonday v1.0.21\ngo: downloading github.com/olekukonko/tablewriter v0.0.5\ngo: downloading github.com/aymanbagabas/go-osc52/v2 v2.0.1\ngo: downloading github.com/lucasb-eyer/go-colorful v1.2.0\ngo: downloading github.com/kr/pretty v0.3.1\ngo: downloading github.com/russross/blackfriday/v2 v2.1.0\ngo: downloading go.opentelemetry.io/contrib/instrumentation/net/http/otelhttp v0.49.0\ngo: downloading github.com/golang/protobuf v1.5.4\ngo: downloading github.com/apparentlymart/go-textseg/v13 v13.0.0\ngo: downloading go.opentelemetry.io/otel/metric v1.36.0\ngo: downloading github.com/go-logr/stdr v1.2.2\ngo: downloading go.opentelemetry.io/auto/sdk v1.1.0\ngo: downloading github.com/cenkalti/backoff/v5 v5.0.2\ngo: downloading github.com/shurcooL/vfsgen v0.0.0-20200824052919-0d455de96546\ngo: downloading github.com/grpc-ecosystem/grpc-gateway/v2 v2.26.3\ngo: downloading go.opentelemetry.io/contrib/instrumentation/google.golang.org/grpc/otelgrpc v0.49.0\ngo: downloading golang.org/x/time v0.5.0\ngo: downloading github.com/jmespath/go-jmespath v0.4.0\ngo: downloading github.com/xeipuuv/gojsonpointer v0.0.0-20180127040702-4e3ac2762d5f\ngo: downloading github.com/cenkalti/backoff/v3 v3.2.2\ngo: downloading github.com/go-jose/go-jose/v3 v3.0.4\ngo: downloading github.com/hashicorp/go-cleanhttp v0.5.2\ngo: downloading github.com/hashicorp/go-retryablehttp v0.7.7\ngo: downloading github.com/hashicorp/go-rootcerts v1.0.2\ngo: downloading github.com/hashicorp/go-secure-stdlib/parseutil v0.1.8\ngo: downloading github.com/hashicorp/go-secure-stdlib/strutil v0.1.2\ngo: downloading github.com/hashicorp/go-hclog v1.6.3\ngo: downloading github.com/mitchellh/mapstructure v1.5.0\ngo: downloading github.com/kylelemons/godebug v1.1.0\ngo: downloading github.com/AzureAD/microsoft-authentication-extensions-for-go/cache v0.1.1\ngo: downloading github.com/cespare/xxhash/v2 v2.3.0\ngo: downloading github.com/dgryski/go-rendezvous v0.0.0-20200823014737-9f7001d12a5f\ngo: downloading github.com/aws/aws-sdk-go-v2/internal/endpoints/v2 v2.6.5\ngo: downloading github.com/Azure/azure-sdk-for-go/sdk/resourcemanager/storage/armstorage v1.5.0\ngo: downloading github.com/google/s2a-go v0.1.7\ngo: downloading github.com/HdrHistogram/hdrhistogram-go v1.1.2\ngo: downloading github.com/Microsoft/go-winio v0.6.1\ngo: downloading github.com/lufia/plan9stats v0.0.0-20211012122336-39d0f177ccd0\ngo: downloading github.com/power-devops/perfstat v0.0.0-20210106213030-5aafc221ea8c\ngo: downloading github.com/tklauser/numcpus v0.4.0\ngo: downloading github.com/cloudflare/circl v1.6.1\ngo: downloading github.com/anmitsu/go-shlex v0.0.0-20200514113438-38f4b401e2be\ngo: downloading gopkg.in/warnings.v0 v0.1.2\ngo: downloading github.com/dlclark/regexp2 v1.11.0\ngo: downloading github.com/aymerick/douceur v0.2.0\ngo: downloading github.com/alecthomas/assert/v2 v2.6.0\ngo: downloading github.com/googleapis/enterprise-certificate-proxy v0.3.2\ngo: downloading github.com/google/martian/v3 v3.3.2\ngo: downloading github.com/google/martian v2.1.0+incompatible\ngo: downloading github.com/alecthomas/repr v0.4.0\ngo: downloading go.opentelemetry.io/otel/sdk/metric v1.34.0\ngo: downloading github.com/felixge/httpsnoop v1.0.4\ngo: downloading github.com/kr/text v0.2.0\ngo: downloading github.com/shurcooL/httpfs v0.0.0-20190707220628-8d4bc4ba7749\ngo: downloading github.com/jmespath/go-jmespath/internal/testify v1.5.1\ngo: downloading github.com/mitchellh/go-homedir v1.1.0\ngo: downloading github.com/hashicorp/go-sockaddr v1.0.6\ngo: downloading github.com/ryanuber/go-glob v1.0.0\ngo: downloading github.com/keybase/go-keychain v0.0.0-20231219164618-57a3676c3af6\ngo: downloading github.com/stretchr/objx v0.5.2\ngo: downloading github.com/gorilla/css v1.0.0\ngo: finding module for package github.com/AdaLogics/go-fuzz-headers\ngo: downloading github.com/AdaLogics/go-fuzz-headers v0.0.0-20240806141605-e8a1dd7889d6\ngo: found github.com/AdaLogics/go-fuzz-headers in github.com/AdaLogics/go-fuzz-headers v0.0.0-20240806141605-e8a1dd7889d6\n+ compile_go_fuzzer github.com/pulumi/pulumi/pkg/v3/codegen/schema SchemaFuzzer schema_fuzzer\n/usr/local/bin/compile_go_fuzzer: line 32: cd: /root/go/src/github.com/pulumi/pulumi/pkg/v3/codegen/schema: No such file or directory\ngithub.com/pulumi/pulumi/pkg/v3/codegen/schema\ngithub.com/pulumi/pulumi/pkg/v3/codegen/schema\nRunning go-fuzz -tags gofuzz -func SchemaFuzzer -o schema_fuzzer.a github.com/pulumi/pulumi/pkg/v3/codegen/schema\n# github.com/pulumi/pulumi/pkg/v3/codegen/schema\ncodegen/schema/schema_fuzzer.go:29:29: not enough arguments in call to ImportSpec\n\thave (PackageSpec, nil)\n\twant (PackageSpec, map[string]Language, ValidationOptions)\n2025/10/14 08:06:30 failed to build packages:exit status 1\nERROR:__main__:Building fuzzers failed.\n'}
2025-10-14 16:07:02,936 - EVENT from author: 'prompt_generate_agent'
  - TOOL_CALL: find_and_append_file_details({'directory_path': '/root/pulumi', 'search_keyword': 'pkg'})
2025-10-14 16:07:03,342 - EVENT from author: 'prompt_generate_agent'
  - TOOL_RESPONSE for 'find_and_append_file_details': {'status': 'success', 'message': "已将 'pkg' 的详细搜索结果追加到 'generated_prompt_file/file_tree.txt'。"}
2025-10-14 16:07:06,115 - EVENT from author: 'prompt_generate_agent'
  - TOOL_CALL: find_and_append_file_details({'directory_path': '/root/pulumi', 'search_keyword': 'codegen/schema'})
2025-10-14 16:07:06,266 - EVENT from author: 'prompt_generate_agent'
  - TOOL_RESPONSE for 'find_and_append_file_details': {'status': 'success', 'message': "已将 'codegen/schema' 的详细搜索结果追加到 'generated_prompt_file/file_tree.txt'。"}
2025-10-14 16:07:09,080 - EVENT from author: 'prompt_generate_agent'
  - TOOL_CALL: read_file_content({'file_path': 'generated_prompt_file/file_tree.txt'})
2025-10-14 16:07:09,082 - EVENT from author: 'prompt_generate_agent'
  - TOOL_RESPONSE for 'read_file_content': {'status': 'error', 'message': "错误：文件 'generated_prompt_file/file_tree.txt' 过大，无法处理。"}
2025-10-14 16:07:12,711 - EVENT from author: 'prompt_generate_agent'
  - TOOL_CALL: find_and_append_file_details({'directory_path': '/root/pulumi', 'search_keyword': 'schema_fuzzer.go'})
2025-10-14 16:07:12,882 - EVENT from author: 'prompt_generate_agent'
  - TOOL_RESPONSE for 'find_and_append_file_details': {'status': 'success', 'message': "在 '/root/pulumi' 中未找到与 'schema_fuzzer.go' 匹配的文件或目录。"}
2025-10-14 16:07:16,122 - EVENT from author: 'prompt_generate_agent'
  - TOOL_CALL: save_file_tree_shallow({'directory_path': '/root/pulumi/pkg', 'max_depth': 3})
2025-10-14 16:07:16,131 - EVENT from author: 'prompt_generate_agent'
  - TOOL_RESPONSE for 'save_file_tree_shallow': {'status': 'success', 'message': "文件树的前 3 层已成功生成并保存到 'generated_prompt_file/file_tree.txt'。"}
2025-10-14 16:07:18,841 - EVENT from author: 'prompt_generate_agent'
  - TOOL_CALL: read_file_content({'file_path': '/root/pulumi/pkg/codegen/schema'})
2025-10-14 16:07:18,843 - EVENT from author: 'prompt_generate_agent'
  - TOOL_RESPONSE for 'read_file_content': {'status': 'error', 'message': "错误：路径 '/root/pulumi/pkg/codegen/schema' 是一个目录，而不是一个文件。"}
2025-10-14 16:07:22,488 - EVENT from author: 'prompt_generate_agent'
  - TOOL_CALL: save_file_tree_shallow({'directory_path': '/root/pulumi/pkg/codegen/schema', 'max_depth': 1})
2025-10-14 16:07:22,492 - EVENT from author: 'prompt_generate_agent'
  - TOOL_RESPONSE for 'save_file_tree_shallow': {'status': 'success', 'message': "文件树的前 1 层已成功生成并保存到 'generated_prompt_file/file_tree.txt'。"}
2025-10-14 16:07:25,392 - EVENT from author: 'prompt_generate_agent'
  - TOOL_CALL: find_and_append_file_details({'directory_path': '/root/pulumi', 'search_keyword': 'ImportSpec'})
2025-10-14 16:07:25,551 - EVENT from author: 'prompt_generate_agent'
  - TOOL_RESPONSE for 'find_and_append_file_details': {'status': 'success', 'message': "在 '/root/pulumi' 中未找到与 'ImportSpec' 匹配的文件或目录。"}
2025-10-14 16:07:28,103 - EVENT from author: 'prompt_generate_agent'
  - TOOL_CALL: read_file_content({'file_path': '/root/pulumi/pkg/codegen/schema/import.go'})
2025-10-14 16:07:28,106 - EVENT from author: 'prompt_generate_agent'
  - TOOL_RESPONSE for 'read_file_content': {'status': 'error', 'message': "错误：文件 '/root/pulumi/pkg/codegen/schema/import.go' 不存在。"}
2025-10-14 16:07:31,472 - EVENT from author: 'prompt_generate_agent'
  - TOOL_CALL: save_file_tree_shallow({'directory_path': '/root/pulumi/pkg/codegen/schema', 'max_depth': 0})
2025-10-14 16:07:31,475 - EVENT from author: 'prompt_generate_agent'
  - TOOL_RESPONSE for 'save_file_tree_shallow': {'status': 'success', 'message': "文件树的前 0 层已成功生成并保存到 'generated_prompt_file/file_tree.txt'。"}
2025-10-14 16:07:34,615 - EVENT from author: 'prompt_generate_agent'
  - TOOL_CALL: read_file_content({'file_path': '/root/pulumi/pkg/codegen/schema'})
2025-10-14 16:07:34,617 - EVENT from author: 'prompt_generate_agent'
  - TOOL_RESPONSE for 'read_file_content': {'status': 'error', 'message': "错误：路径 '/root/pulumi/pkg/codegen/schema' 是一个目录，而不是一个文件。"}
2025-10-14 16:07:37,764 - EVENT from author: 'prompt_generate_agent'
  - TOOL_CALL: save_file_tree({'directory_path': '/root/pulumi/pkg/codegen/schema'})
2025-10-14 16:07:37,768 - EVENT from author: 'prompt_generate_agent'
  - TOOL_RESPONSE for 'save_file_tree': {'status': 'success', 'message': "文件树已成功生成并保存到文件 'generated_prompt_file/file_tree.txt' 中。"}
2025-10-14 16:07:41,088 - EVENT from author: 'prompt_generate_agent'
  - TOOL_CALL: read_file_content({'file_path': '/root/pulumi/pkg/codegen/schema/schema.go'})
2025-10-14 16:07:41,099 - EVENT from author: 'prompt_generate_agent'
  - TOOL_RESPONSE for 'read_file_content': {'status': 'success', 'message': "文件 '/root/pulumi/pkg/codegen/schema/schema.go' 的内容已成功读取并加载到内存中。", 'content': '// Copyright 2016-2022, Pulumi Corporation.\n//\n// Licensed under the Apache License, Version 2.0 (the "License");\n// you may not use this file except in compliance with the License.\n// You may obtain a copy of the License at\n//\n//     http://www.apache.org/licenses/LICENSE-2.0\n//\n// Unless required by applicable law or agreed to in writing, software\n// distributed under the License is distributed on an "AS IS" BASIS,\n// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n// See the License for the specific language governing permissions and\n// limitations under the License.\n\npackage schema\n\nimport (\n\t"bytes"\n\t"context"\n\t"encoding/json"\n\t"fmt"\n\t"net/url"\n\t"regexp"\n\t"sort"\n\t"strings"\n\n\t"github.com/blang/semver"\n\t"github.com/hashicorp/hcl/v2"\n\t"github.com/pulumi/pulumi/sdk/v3/go/common/apitype"\n\t"github.com/pulumi/pulumi/sdk/v3/go/common/slice"\n\t"github.com/pulumi/pulumi/sdk/v3/go/common/workspace"\n\n\t"gopkg.in/yaml.v3"\n)\n\n// TODO:\n// - Providerless packages\n\n// Type represents a datatype in the Pulumi Schema. Types created by this package are identical if they are\n// equal values.\ntype Type interface {\n\tString() string\n\n\tisType()\n}\n\ntype primitiveType int\n\nconst (\n\tboolType        primitiveType = 1\n\tintType         primitiveType = 2\n\tnumberType      primitiveType = 3\n\tstringType      primitiveType = 4\n\tarchiveType     primitiveType = 5\n\tassetType       primitiveType = 6\n\tanyType         primitiveType = 7\n\tjsonType        primitiveType = 8\n\tanyResourceType primitiveType = 9\n)\n\nfunc (t primitiveType) String() string {\n\tswitch t {\n\tcase boolType:\n\t\treturn "boolean"\n\tcase intType:\n\t\treturn "integer"\n\tcase numberType:\n\t\treturn "number"\n\tcase stringType:\n\t\treturn "string"\n\tcase archiveType:\n\t\treturn "pulumi:pulumi:Archive"\n\tcase assetType:\n\t\treturn "pulumi:pulumi:Asset"\n\tcase jsonType:\n\t\tfallthrough\n\tcase anyResourceType:\n\t\tfallthrough\n\tcase anyType:\n\t\treturn "pulumi:pulumi:Any"\n\tdefault:\n\t\tpanic("unknown primitive type")\n\t}\n}\n\nfunc (primitiveType) isType() {}\n\n// IsPrimitiveType returns true if the given Type is a primitive type. The primitive types are bool, int, number,\n// string, archive, asset, and any.\nfunc IsPrimitiveType(t Type) bool {\n\t_, ok := plainType(t).(primitiveType)\n\treturn ok\n}\n\nvar (\n\t// BoolType represents the set of boolean values.\n\tBoolType Type = boolType\n\t// IntType represents the set of 32-bit integer values.\n\tIntType Type = intType\n\t// NumberType represents the set of IEEE754 double-precision values.\n\tNumberType Type = numberType\n\t// StringType represents the set of UTF-8 string values.\n\tStringType Type = stringType\n\t// ArchiveType represents the set of Pulumi Archive values.\n\tArchiveType Type = archiveType\n\t// AssetType represents the set of Pulumi Asset values.\n\tAssetType Type = assetType\n\t// JSONType represents the set of JSON-encoded values.\n\tJSONType Type = jsonType\n\t// AnyType represents the complete set of values.\n\tAnyType Type = anyType\n\t// AnyResourceType represents any Pulumi resource - custom or component\n\tAnyResourceType Type = anyResourceType\n)\n\n// An InvalidType represents an invalid type with associated diagnostics.\ntype InvalidType struct {\n\tDiagnostics hcl.Diagnostics\n}\n\nfunc (t *InvalidType) String() string {\n\treturn "Invalid"\n}\n\nfunc (*InvalidType) isType() {}\n\nfunc invalidType(diags ...*hcl.Diagnostic) (Type, hcl.Diagnostics) {\n\tt := &InvalidType{Diagnostics: hcl.Diagnostics(diags)}\n\treturn t, hcl.Diagnostics(diags)\n}\n\n// MapType represents maps from strings to particular element types.\ntype MapType struct {\n\t// ElementType is the element type of the map.\n\tElementType Type\n}\n\nfunc (t *MapType) String() string {\n\treturn fmt.Sprintf("Map<%v>", t.ElementType)\n}\n\nfunc (*MapType) isType() {}\n\n// ArrayType represents arrays of particular element types.\ntype ArrayType struct {\n\t// ElementType is the element type of the array.\n\tElementType Type\n}\n\nfunc (t *ArrayType) String() string {\n\treturn fmt.Sprintf("Array<%v>", t.ElementType)\n}\n\nfunc (*ArrayType) isType() {}\n\n// EnumType represents an enum.\ntype EnumType struct {\n\t// PackageReference is the PackageReference that defines the resource.\n\tPackageReference PackageReference\n\t// Token is the type\'s Pulumi type token.\n\tToken string\n\t// Comment is the description of the type, if any.\n\tComment string\n\t// Elements are the predefined enum values.\n\tElements []*Enum\n\t// ElementType is the underlying type for the enum.\n\tElementType Type\n\n\t// IsOverlay indicates whether the type is an overlay provided by the package. Overlay code is generated by the\n\t// package rather than using the core Pulumi codegen libraries.\n\tIsOverlay bool\n}\n\n// Enum contains information about an enum.\ntype Enum struct {\n\t// Value is the value of the enum.\n\tValue any\n\t// Comment is the description for the enum value.\n\tComment string\n\t// Name for the enum.\n\tName string\n\t// DeprecationMessage indicates whether or not the value is deprecated.\n\tDeprecationMessage string\n}\n\nfunc (t *EnumType) String() string {\n\treturn t.Token\n}\n\nfunc (*EnumType) isType() {}\n\n// UnionType represents values that may be any one of a specified set of types.\ntype UnionType struct {\n\t// ElementTypes are the allowable types for the union type.\n\tElementTypes []Type\n\t// DefaultType is the default type, if any, for the union type. This can be used by targets that do not support\n\t// unions, or in positions where unions are not appropriate.\n\tDefaultType Type\n\t// Discriminator informs the consumer of an alternative schema based on the value associated with it.\n\tDiscriminator string\n\t// Mapping is an optional object to hold mappings between payload values and schema names or references.\n\tMapping map[string]string\n}\n\nfunc (t *UnionType) String() string {\n\telements := make([]string, len(t.ElementTypes))\n\tfor i, e := range t.ElementTypes {\n\t\telements[i] = e.String()\n\t}\n\n\tif t.DefaultType != nil {\n\t\telements = append(elements, "default="+t.DefaultType.String())\n\t}\n\n\treturn fmt.Sprintf("Union<%v>", strings.Join(elements, ", "))\n}\n\nfunc (*UnionType) isType() {}\n\n// ObjectType represents schematized maps from strings to particular types.\ntype ObjectType struct {\n\t// PackageReference is the PackageReference that defines the resource.\n\tPackageReference PackageReference\n\t// Token is the type\'s Pulumi type token.\n\tToken string\n\t// Comment is the description of the type, if any.\n\tComment string\n\t// Properties is the list of the type\'s properties.\n\tProperties []*Property\n\t// Language specifies additional language-specific data about the object type.\n\tLanguage map[string]any\n\t// IsOverlay indicates whether the type is an overlay provided by the package. Overlay code is generated by the\n\t// package rather than using the core Pulumi codegen libraries.\n\tIsOverlay bool\n\t// OverlaySupportedLanguages indicates what languages the overlay supports. This only has an effect if\n\t// the Resource is an Overlay (IsOverlay == true).\n\t// Supported values are "nodejs", "python", "go", "csharp", "java", "yaml"\n\tOverlaySupportedLanguages []string\n\n\t// InputShape is the input shape for this object. Only valid if IsPlainShape returns true.\n\tInputShape *ObjectType\n\t// PlainShape is the plain shape for this object. Only valid if IsInputShape returns true.\n\tPlainShape *ObjectType\n\n\tproperties map[string]*Property\n}\n\n// IsPlainShape returns true if this object type is the plain shape of a (plain, input)\n// pair. The plain shape of an object does not contain *InputType values and only\n// references other plain shapes.\nfunc (t *ObjectType) IsPlainShape() bool {\n\treturn t.PlainShape == nil\n}\n\n// IsInputShape returns true if this object type is the input shape of a (plain, input)\n// pair. The input shape of an object may contain *InputType values and may\n// reference other input shapes.\nfunc (t *ObjectType) IsInputShape() bool {\n\treturn t.PlainShape != nil\n}\n\nfunc (t *ObjectType) Property(name string) (*Property, bool) {\n\tif t.properties == nil && len(t.Properties) > 0 {\n\t\tt.properties = make(map[string]*Property)\n\t\tfor _, p := range t.Properties {\n\t\t\tt.properties[p.Name] = p\n\t\t}\n\t}\n\tp, ok := t.properties[name]\n\treturn p, ok\n}\n\nfunc (t *ObjectType) String() string {\n\tif t.PlainShape != nil {\n\t\treturn t.Token + "•Input"\n\t}\n\treturn t.Token\n}\n\nfunc (*ObjectType) isType() {}\n\ntype ResourceType struct {\n\t// Token is the type\'s Pulumi type token.\n\tToken string\n\t// Resource is the type\'s underlying resource.\n\tResource *Resource\n}\n\nfunc (t *ResourceType) String() string {\n\treturn t.Token\n}\n\nfunc (t *ResourceType) isType() {}\n\n// TokenType represents an opaque type that is referred to only by its token. A TokenType may have an underlying type\n// that can be used in place of the token.\ntype TokenType struct {\n\t// Token is the type\'s Pulumi type token.\n\tToken string\n\t// Underlying type is the type\'s underlying type, if any.\n\tUnderlyingType Type\n}\n\nfunc (t *TokenType) String() string {\n\treturn t.Token\n}\n\nfunc (*TokenType) isType() {}\n\n// InputType represents a type that accepts either a prompt value or an output value.\ntype InputType struct {\n\t// ElementType is the element type of the input.\n\tElementType Type\n}\n\nfunc (t *InputType) String() string {\n\treturn fmt.Sprintf("Input<%v>", t.ElementType)\n}\n\nfunc (*InputType) isType() {}\n\n// OptionalType represents a type that accepts an optional value.\ntype OptionalType struct {\n\t// ElementType is the element type of the input.\n\tElementType Type\n}\n\nfunc (t *OptionalType) String() string {\n\treturn fmt.Sprintf("Optional<%v>", t.ElementType)\n}\n\nfunc (*OptionalType) isType() {}\n\n// DefaultValue describes a default value for a property.\ntype DefaultValue struct {\n\t// Value specifies a static default value, if any. This value must be representable in the Pulumi schema type\n\t// system, and its type must be assignable to that of the property to which the default applies.\n\tValue any\n\t// Environment specifies a set of environment variables to probe for a default value.\n\tEnvironment []string\n\t// Language specifies additional language-specific data about the default value.\n\tLanguage map[string]any\n}\n\n// Property describes an object or resource property.\ntype Property struct {\n\t// Name is the name of the property.\n\tName string\n\t// Comment is the description of the property, if any.\n\tComment string\n\t// Type is the type of the property.\n\tType Type\n\t// ConstValue is the constant value for the property, if any.\n\tConstValue any\n\t// DefaultValue is the default value for the property, if any.\n\tDefaultValue *DefaultValue\n\t// DeprecationMessage indicates whether or not the property is deprecated.\n\tDeprecationMessage string\n\t// Language specifies additional language-specific data about the property.\n\tLanguage map[string]any\n\t// Secret is true if the property is secret (default false).\n\tSecret bool\n\t// ReplaceOnChanges specifies if the property is to be replaced instead of updated (default false).\n\tReplaceOnChanges bool\n\t// WillReplaceOnChanges indicates that the provider will replace the resource when\n\t// this property is changed. This property is used exclusively for docs.\n\tWillReplaceOnChanges bool\n\tPlain                bool\n}\n\n// IsRequired returns true if this property is required (i.e. its type is not Optional).\nfunc (p *Property) IsRequired() bool {\n\t_, optional := p.Type.(*OptionalType)\n\treturn !optional\n}\n\n// Alias describes an alias for a Pulumi resource.\ntype Alias struct {\n\t// This is true if the alias is an old style object alias, and should be written back out as such.\n\tcompatibility bool\n\n\t// The type alias.\n\tType string\n}\n\n// Resource describes a Pulumi resource.\ntype Resource struct {\n\t// PackageReference is the PackageReference that defines the resource.\n\tPackageReference PackageReference\n\t// Token is the resource\'s Pulumi type token.\n\tToken string\n\t// Comment is the description of the resource, if any.\n\tComment string\n\t// IsProvider is true if the resource is a provider resource.\n\tIsProvider bool\n\t// InputProperties is the list of the resource\'s input properties.\n\tInputProperties []*Property\n\t// Properties is the list of the resource\'s output properties. This should be a superset of the input properties.\n\tProperties []*Property\n\t// StateInputs is the set of inputs used to get an existing resource, if any.\n\tStateInputs *ObjectType\n\t// Aliases is the list of aliases for the resource.\n\tAliases []*Alias\n\t// DeprecationMessage indicates whether or not the resource is deprecated.\n\tDeprecationMessage string\n\t// Language specifies additional language-specific data about the resource.\n\tLanguage map[string]any\n\t// IsComponent indicates whether the resource is a ComponentResource.\n\tIsComponent bool\n\t// Methods is the list of methods for the resource.\n\tMethods []*Method\n\t// IsOverlay indicates whether the type is an overlay provided by the package. Overlay code is generated by the\n\t// package rather than using the core Pulumi codegen libraries.\n\tIsOverlay bool\n\t// OverlaySupportedLanguages indicates what languages the overlay supports. This only has an effect if\n\t// the Resource is an Overlay (IsOverlay == true).\n\t// Supported values are "nodejs", "python", "go", "csharp", "java", "yaml"\n\tOverlaySupportedLanguages []string\n}\n\n// The set of resource paths where ReplaceOnChanges is true.\n//\n// For example, if you have the following resource struct:\n//\n// Resource A {\n//\n//\tProperties: {\n//\t\t Object B {\n//\t\t   Object D: {\n//\t\t     ReplaceOnChanges: true\n//\t\t     }\n//\t\t   Object F: {}\n//\t    }\n//\t\t Object C {\n//\t\t   ReplaceOnChanges: true\n//\t\t   }\n//\t  }\n//\t}\n//\n// A.ReplaceOnChanges() == [[B, D], [C]]\nfunc (r *Resource) ReplaceOnChanges() (changes [][]*Property, err []error) {\n\tfor _, p := range r.Properties {\n\t\tif p.ReplaceOnChanges {\n\t\t\tchanges = append(changes, []*Property{p})\n\t\t} else {\n\t\t\tstack := map[string]struct{}{p.Type.String(): {}}\n\t\t\tchildChanges, errList := replaceOnChangesType(p.Type, &stack)\n\t\t\terr = append(err, errList...)\n\n\t\t\tfor _, c := range childChanges {\n\t\t\t\tchanges = append(changes, append([]*Property{p}, c...))\n\t\t\t}\n\t\t}\n\t}\n\tfor i, e := range err {\n\t\terr[i] = fmt.Errorf("Failed to genereate full `ReplaceOnChanges`: %w", e)\n\t}\n\treturn changes, err\n}\n\nfunc replaceOnChangesType(t Type, stack *map[string]struct{}) ([][]*Property, []error) {\n\tvar errTmp []error\n\tif o, ok := t.(*OptionalType); ok {\n\t\treturn replaceOnChangesType(o.ElementType, stack)\n\t} else if o, ok := t.(*ObjectType); ok {\n\t\tchanges := [][]*Property{}\n\t\terr := []error{}\n\t\tfor _, p := range o.Properties {\n\t\t\tif p.ReplaceOnChanges {\n\t\t\t\tchanges = append(changes, []*Property{p})\n\t\t\t} else if _, ok := (*stack)[p.Type.String()]; !ok {\n\t\t\t\t// We handle recursive objects\n\t\t\t\t(*stack)[p.Type.String()] = struct{}{}\n\t\t\t\tvar object [][]*Property\n\t\t\t\tobject, errTmp = replaceOnChangesType(p.Type, stack)\n\t\t\t\terr = append(err, errTmp...)\n\t\t\t\tfor _, path := range object {\n\t\t\t\t\tchanges = append(changes, append([]*Property{p}, path...))\n\t\t\t\t}\n\n\t\t\t\tdelete(*stack, p.Type.String())\n\t\t\t} else {\n\t\t\t\terr = append(err, fmt.Errorf("Found recursive object %q", p.Name))\n\t\t\t}\n\t\t}\n\t\t// We don\'t want to emit errors where replaceOnChanges is not used.\n\t\tif len(changes) == 0 {\n\t\t\treturn nil, nil\n\t\t}\n\t\treturn changes, err\n\t} else if a, ok := t.(*ArrayType); ok {\n\t\t// This looks for types internal to the array, not a property of the array.\n\t\treturn replaceOnChangesType(a.ElementType, stack)\n\t} else if m, ok := t.(*MapType); ok {\n\t\t// This looks for types internal to the map, not a property of the array.\n\t\treturn replaceOnChangesType(m.ElementType, stack)\n\t}\n\treturn nil, nil\n}\n\n// Joins the output of `ReplaceOnChanges` into property path names.\n//\n// For example, given an input [[B, D], [C]] where each property has a name\n// equivalent to it\'s variable, this function should yield: ["B.D", "C"]\nfunc PropertyListJoinToString(propertyList [][]*Property, nameConverter func(string) string) []string {\n\tvar nonOptional func(Type) Type\n\tnonOptional = func(t Type) Type {\n\t\tif o, ok := t.(*OptionalType); ok {\n\t\t\treturn nonOptional(o.ElementType)\n\t\t}\n\t\treturn t\n\t}\n\tout := make([]string, len(propertyList))\n\tfor i, p := range propertyList {\n\t\tnames := make([]string, len(p))\n\t\tfor j, n := range p {\n\t\t\tif _, ok := nonOptional(n.Type).(*ArrayType); ok {\n\t\t\t\tnames[j] = nameConverter(n.Name) + "[*]"\n\t\t\t} else if _, ok := nonOptional(n.Type).(*MapType); ok {\n\t\t\t\tnames[j] = nameConverter(n.Name) + ".*"\n\t\t\t} else {\n\t\t\t\tnames[j] = nameConverter(n.Name)\n\t\t\t}\n\t\t}\n\t\tout[i] = strings.Join(names, ".")\n\t}\n\treturn out\n}\n\ntype Method struct {\n\t// Name is the name of the method.\n\tName string\n\t// Function is the function definition for the method.\n\tFunction *Function\n}\n\n// Function describes a Pulumi function.\ntype Function struct {\n\t// PackageReference is the PackageReference that defines the function.\n\tPackageReference PackageReference\n\t// Token is the function\'s Pulumi type token.\n\tToken string\n\t// Comment is the description of the function, if any.\n\tComment string\n\t// Inputs is the bag of input values for the function, if any.\n\tInputs *ObjectType\n\t// Determines whether the input bag should be treated as a single argument or as multiple arguments.\n\tMultiArgumentInputs bool\n\t// Outputs is the bag of output values for the function, if any.\n\tOutputs *ObjectType\n\t// The return type of the function, if any.\n\tReturnType Type\n\t// The return type is plain and not wrapped in an Output.\n\tReturnTypePlain bool\n\t// When InlineObjectAsReturnType is true, it means that the return type definition is defined inline\n\t// as an object type that should be generated as a separate type and it is not\n\t// a reference to a existing type in the schema.\n\tInlineObjectAsReturnType bool\n\t// DeprecationMessage indicates whether or not the function is deprecated.\n\tDeprecationMessage string\n\t// Language specifies additional language-specific data about the function.\n\tLanguage map[string]any\n\t// IsMethod indicates whether the function is a method of a resource.\n\tIsMethod bool\n\t// IsOverlay indicates whether the function is an overlay provided by the package. Overlay code is generated by the\n\t// package rather than using the core Pulumi codegen libraries.\n\tIsOverlay bool\n\t// OverlaySupportedLanguages indicates what languages the overlay supports. This only has an effect if\n\t// the Resource is an Overlay (IsOverlay == true).\n\t// Supported values are "nodejs", "python", "go", "csharp", "java", "yaml"\n\tOverlaySupportedLanguages []string\n}\n\n// NeedsOutputVersion determines if codegen should emit a ${fn}Output version that\n// automatically accepts Inputs and returns ReturnType.\nfunc (fun *Function) NeedsOutputVersion() bool {\n\t// Skip functions that return no value. Arguably we could\n\t// support them and return `Task`, but there are no such\n\t// functions in `pulumi-azure-native` or `pulumi-aws` so we\n\t// omit to simplify.\n\treturn fun.ReturnType != nil\n}\n\n// BaseProvider\ntype BaseProvider struct {\n\t// Name is the name of the provider.\n\tName string\n\t// Version is the version of the provider.\n\tVersion semver.Version\n}\n\ntype Parameterization struct {\n\tBaseProvider BaseProvider\n\t// Parameter is the parameter for the provider.\n\tParameter []byte\n}\n\n// Package describes a Pulumi package.\ntype Package struct {\n\t// True if this package should be written in the new style to support pack and conformance testing.\n\tSupportPack bool\n\n\tmoduleFormat *regexp.Regexp\n\n\t// Name is the unqualified name of the package (e.g. "aws", "azure", "gcp", "kubernetes". "random")\n\tName string\n\t// DisplayName is the human-friendly name of the package.\n\tDisplayName string\n\t// Version is the version of the package.\n\tVersion *semver.Version\n\t// Description is the description of the package.\n\tDescription string\n\t// Keywords is the list of keywords that are associated with the package, if any.\n\t// Some reserved keywords can be specified as well that help with categorizing the\n\t// package in the Pulumi registry. `category/<name>` and `kind/<type>` are the only\n\t// reserved keywords at this time, where `<name>` can be one of:\n\t// `cloud`, `database`, `infrastructure`, `monitoring`, `network`, `utility`, `vcs`\n\t// and `<type>` is either `native` or `component`. If the package is a bridged Terraform\n\t// provider, then don\'t include the `kind/` label.\n\tKeywords []string\n\t// Homepage is the package\'s homepage.\n\tHomepage string\n\t// License indicates which license is used for the package\'s contents.\n\tLicense string\n\t// Attribution allows freeform text attribution of derived work, if needed.\n\tAttribution string\n\t// Repository is the URL at which the source for the package can be found.\n\tRepository string\n\t// LogoURL is the URL for the package\'s logo, if any.\n\tLogoURL string\n\t// PluginDownloadURL is the URL to use to acquire the provider plugin binary, if any.\n\tPluginDownloadURL string\n\t// Publisher is the name of the person or organization that authored and published the package.\n\tPublisher string\n\t// Namespace is the namespace of the package, that\'s used to diambiguate the package name.\n\tNamespace string\n\t// A list of allowed package name in addition to the Name property.\n\tAllowedPackageNames []string\n\n\t// Types is the list of non-resource types defined by the package.\n\tTypes []Type\n\t// Config is the set of configuration properties defined by the package.\n\tConfig []*Property\n\t// Provider is the resource provider for the package, if any.\n\tProvider *Resource\n\t// Resources is the list of resource types defined by the package.\n\tResources []*Resource\n\t// Functions is the list of functions defined by the package.\n\tFunctions []*Function\n\t// Language specifies additional language-specific data about the package.\n\tLanguage map[string]any\n\t// Dependencies specifies the dependencies of the package\n\tDependencies []PackageDescriptor\n\n\t// Parameterization is the optional parameterization for the package, if any.\n\tParameterization *Parameterization\n\n\tresourceTable     map[string]*Resource\n\tresourceTypeTable map[string]*ResourceType\n\tfunctionTable     map[string]*Function\n\ttypeTable         map[string]Type\n\n\timportedLanguages map[string]struct{}\n}\n\n// Language provides hooks for importing language-specific metadata in a package.\ntype Language interface {\n\t// ImportDefaultSpec decodes language-specific metadata associated with a DefaultValue.\n\tImportDefaultSpec(bytes json.RawMessage) (any, error)\n\t// ImportPropertySpec decodes language-specific metadata associated with a Property.\n\tImportPropertySpec(bytes json.RawMessage) (any, error)\n\t// ImportObjectTypeSpec decodes language-specific metadata associated with a ObjectType.\n\tImportObjectTypeSpec(bytes json.RawMessage) (any, error)\n\t// ImportResourceSpec decodes language-specific metadata associated with a Resource.\n\tImportResourceSpec(bytes json.RawMessage) (any, error)\n\t// ImportFunctionSpec decodes language-specific metadata associated with a Function.\n\tImportFunctionSpec(bytes json.RawMessage) (any, error)\n\t// ImportPackageSpec decodes language-specific metadata associated with a Package.\n\tImportPackageSpec(bytes json.RawMessage) (any, error)\n}\n\nfunc sortedLanguageNames(metadata map[string]any) []string {\n\tnames := slice.Prealloc[string](len(metadata))\n\tfor lang := range metadata {\n\t\tnames = append(names, lang)\n\t}\n\tsort.Strings(names)\n\treturn names\n}\n\nfunc importDefaultLanguages(def *DefaultValue, languages map[string]Language) error {\n\tfor _, name := range sortedLanguageNames(def.Language) {\n\t\tval := def.Language[name]\n\t\tif raw, ok := val.(json.RawMessage); ok {\n\t\t\tif lang, ok := languages[name]; ok {\n\t\t\t\tval, err := lang.ImportDefaultSpec(raw)\n\t\t\t\tif err != nil {\n\t\t\t\t\treturn fmt.Errorf("importing %v metadata: %w", name, err)\n\t\t\t\t}\n\t\t\t\tdef.Language[name] = val\n\t\t\t}\n\t\t}\n\t}\n\treturn nil\n}\n\nfunc importPropertyLanguages(property *Property, languages map[string]Language) error {\n\tif property.DefaultValue != nil {\n\t\tif err := importDefaultLanguages(property.DefaultValue, languages); err != nil {\n\t\t\treturn fmt.Errorf("importing default value: %w", err)\n\t\t}\n\t}\n\n\tfor _, name := range sortedLanguageNames(property.Language) {\n\t\tval := property.Language[name]\n\t\tif raw, ok := val.(json.RawMessage); ok {\n\t\t\tif lang, ok := languages[name]; ok {\n\t\t\t\tval, err := lang.ImportPropertySpec(raw)\n\t\t\t\tif err != nil {\n\t\t\t\t\treturn fmt.Errorf("importing %v metadata: %w", name, err)\n\t\t\t\t}\n\t\t\t\tproperty.Language[name] = val\n\t\t\t}\n\t\t}\n\t}\n\treturn nil\n}\n\nfunc importObjectTypeLanguages(object *ObjectType, languages map[string]Language) error {\n\tfor _, property := range object.Properties {\n\t\tif err := importPropertyLanguages(property, languages); err != nil {\n\t\t\treturn fmt.Errorf("importing property %v: %w", property.Name, err)\n\t\t}\n\t}\n\n\tfor _, name := range sortedLanguageNames(object.Language) {\n\t\tval := object.Language[name]\n\t\tif raw, ok := val.(json.RawMessage); ok {\n\t\t\tif lang, ok := languages[name]; ok {\n\t\t\t\tval, err := lang.ImportObjectTypeSpec(raw)\n\t\t\t\tif err != nil {\n\t\t\t\t\treturn fmt.Errorf("importing %v metadata: %w", name, err)\n\t\t\t\t}\n\t\t\t\tobject.Language[name] = val\n\t\t\t}\n\t\t}\n\t}\n\treturn nil\n}\n\nfunc importResourceLanguages(resource *Resource, languages map[string]Language) error {\n\tfor _, property := range resource.InputProperties {\n\t\tif err := importPropertyLanguages(property, languages); err != nil {\n\t\t\treturn fmt.Errorf("importing input property %v: %w", property.Name, err)\n\t\t}\n\t}\n\n\tfor _, property := range resource.Properties {\n\t\tif err := importPropertyLanguages(property, languages); err != nil {\n\t\t\treturn fmt.Errorf("importing property %v: %w", property.Name, err)\n\t\t}\n\t}\n\n\tif resource.StateInputs != nil {\n\t\tfor _, property := range resource.StateInputs.Properties {\n\t\t\tif err := importPropertyLanguages(property, languages); err != nil {\n\t\t\t\treturn fmt.Errorf("importing state input property %v: %w", property.Name, err)\n\t\t\t}\n\t\t}\n\t}\n\n\tfor _, name := range sortedLanguageNames(resource.Language) {\n\t\tval := resource.Language[name]\n\t\tif raw, ok := val.(json.RawMessage); ok {\n\t\t\tif lang, ok := languages[name]; ok {\n\t\t\t\tval, err := lang.ImportResourceSpec(raw)\n\t\t\t\tif err != nil {\n\t\t\t\t\treturn fmt.Errorf("importing %v metadata: %w", name, err)\n\t\t\t\t}\n\t\t\t\tresource.Language[name] = val\n\t\t\t}\n\t\t}\n\t}\n\treturn nil\n}\n\nfunc importFunctionLanguages(function *Function, languages map[string]Language) error {\n\tif function.Inputs != nil {\n\t\tif err := importObjectTypeLanguages(function.Inputs, languages); err != nil {\n\t\t\treturn fmt.Errorf("importing inputs: %w", err)\n\t\t}\n\t}\n\tif function.ReturnType != nil {\n\t\tif objectType, ok := function.ReturnType.(*ObjectType); ok && objectType != nil {\n\t\t\tif err := importObjectTypeLanguages(objectType, languages); err != nil {\n\t\t\t\treturn fmt.Errorf("importing outputs: %w", err)\n\t\t\t}\n\t\t}\n\t}\n\n\tfor _, name := range sortedLanguageNames(function.Language) {\n\t\tval := function.Language[name]\n\t\tif raw, ok := val.(json.RawMessage); ok {\n\t\t\tif lang, ok := languages[name]; ok {\n\t\t\t\tval, err := lang.ImportFunctionSpec(raw)\n\t\t\t\tif err != nil {\n\t\t\t\t\treturn fmt.Errorf("importing %v metadata: %w", name, err)\n\t\t\t\t}\n\t\t\t\tfunction.Language[name] = val\n\t\t\t}\n\t\t}\n\t}\n\treturn nil\n}\n\nfunc (pkg *Package) ImportLanguages(languages map[string]Language) error {\n\tif pkg.importedLanguages == nil {\n\t\tpkg.importedLanguages = map[string]struct{}{}\n\t}\n\n\tfound := false\n\tfor lang := range languages {\n\t\tif _, ok := pkg.importedLanguages[lang]; !ok {\n\t\t\tfound = true\n\t\t\tbreak\n\t\t}\n\t}\n\tif !found {\n\t\treturn nil\n\t}\n\n\tfor _, t := range pkg.Types {\n\t\tif object, ok := t.(*ObjectType); ok {\n\t\t\tif err := importObjectTypeLanguages(object, languages); err != nil {\n\t\t\t\treturn fmt.Errorf("importing object type %v: %w", object.Token, err)\n\t\t\t}\n\t\t}\n\t}\n\n\tfor _, config := range pkg.Config {\n\t\tif err := importPropertyLanguages(config, languages); err != nil {\n\t\t\treturn fmt.Errorf("importing configuration property %v: %w", config.Name, err)\n\t\t}\n\t}\n\n\tif pkg.Provider != nil {\n\t\tif err := importResourceLanguages(pkg.Provider, languages); err != nil {\n\t\t\treturn fmt.Errorf("importing provider: %w", err)\n\t\t}\n\t}\n\n\tfor _, resource := range pkg.Resources {\n\t\tif err := importResourceLanguages(resource, languages); err != nil {\n\t\t\treturn fmt.Errorf("importing resource %v: %w", resource.Token, err)\n\t\t}\n\t}\n\n\tfor _, function := range pkg.Functions {\n\t\tif err := importFunctionLanguages(function, languages); err != nil {\n\t\t\treturn fmt.Errorf("importing function %v: %w", function.Token, err)\n\t\t}\n\t}\n\n\tfor _, name := range sortedLanguageNames(pkg.Language) {\n\t\tval := pkg.Language[name]\n\t\tif raw, ok := val.(json.RawMessage); ok {\n\t\t\tif lang, ok := languages[name]; ok {\n\t\t\t\tval, err := lang.ImportPackageSpec(raw)\n\t\t\t\tif err != nil {\n\t\t\t\t\treturn fmt.Errorf("importing %v metadata: %w", name, err)\n\t\t\t\t}\n\t\t\t\tpkg.Language[name] = val\n\t\t\t}\n\t\t}\n\t}\n\n\tfor lang := range languages {\n\t\tpkg.importedLanguages[lang] = struct{}{}\n\t}\n\n\treturn nil\n}\n\nfunc packageIdentity(name string, version *semver.Version) string {\n\t// The package\'s identity is its name and version (if any) separated buy a \':\'. The \':\' character is not allowed\n\t// in package names and so is safe to use as a separator.\n\tid := name + ":"\n\tif version != nil {\n\t\treturn id + version.String()\n\t}\n\treturn id\n}\n\nfunc (pkg *Package) Identity() string {\n\treturn packageIdentity(pkg.Name, pkg.Version)\n}\n\nfunc (pkg *Package) Equals(other *Package) bool {\n\treturn pkg == other || pkg.Identity() == other.Identity()\n}\n\nvar defaultModuleFormat = regexp.MustCompile("(.*)")\n\nfunc (pkg *Package) TokenToModule(tok string) string {\n\t// token := pkg ":" module ":" member\n\n\tcomponents := strings.Split(tok, ":")\n\tif len(components) != 3 {\n\t\treturn ""\n\t}\n\n\tswitch components[1] {\n\tcase "providers":\n\t\treturn ""\n\tdefault:\n\t\tformat := pkg.moduleFormat\n\t\tif format == nil {\n\t\t\tformat = defaultModuleFormat\n\t\t}\n\n\t\tmatches := format.FindStringSubmatch(components[1])\n\t\tif len(matches) < 2 || strings.HasPrefix(matches[1], "index") {\n\t\t\treturn ""\n\t\t}\n\t\treturn matches[1]\n\t}\n}\n\nfunc TokenToRuntimeModule(tok string) string {\n\t// token := pkg ":" module ":" member\n\n\tcomponents := strings.Split(tok, ":")\n\tif len(components) != 3 {\n\t\treturn ""\n\t}\n\treturn components[1]\n}\n\nfunc (pkg *Package) TokenToRuntimeModule(tok string) string {\n\treturn TokenToRuntimeModule(tok)\n}\n\nfunc (pkg *Package) GetResource(token string) (*Resource, bool) {\n\tr, ok := pkg.resourceTable[token]\n\treturn r, ok\n}\n\nfunc (pkg *Package) GetFunction(token string) (*Function, bool) {\n\tf, ok := pkg.functionTable[token]\n\treturn f, ok\n}\n\nfunc (pkg *Package) GetResourceType(token string) (*ResourceType, bool) {\n\tt, ok := pkg.resourceTypeTable[token]\n\treturn t, ok\n}\n\nfunc (pkg *Package) GetType(token string) (Type, bool) {\n\tt, ok := pkg.typeTable[token]\n\treturn t, ok\n}\n\nfunc (pkg *Package) Reference() PackageReference {\n\treturn packageDefRef{pkg: pkg}\n}\n\nfunc (pkg *Package) Descriptor(ctx context.Context) (workspace.PackageDescriptor, error) {\n\tversion := pkg.Version\n\tif pkg.Parameterization != nil {\n\t\tversion = &pkg.Parameterization.BaseProvider.Version\n\t}\n\tname := pkg.Name\n\tif pkg.Parameterization != nil {\n\t\tname = pkg.Parameterization.BaseProvider.Name\n\t}\n\tpluginSpec, err := workspace.NewPluginSpec(ctx, name, apitype.ResourcePlugin, version,\n\t\tpkg.PluginDownloadURL, nil)\n\tif err != nil {\n\t\treturn workspace.PackageDescriptor{}, err\n\t}\n\tvar parameterization *workspace.Parameterization\n\tif pkg.Parameterization != nil {\n\t\tparameterization = &workspace.Parameterization{\n\t\t\tName:    pkg.Name,\n\t\t\tVersion: *pkg.Version,\n\t\t\tValue:   pkg.Parameterization.Parameter,\n\t\t}\n\t}\n\treturn workspace.NewPackageDescriptor(pluginSpec, parameterization), nil\n}\n\nfunc (pkg *Package) MarshalSpec() (spec *PackageSpec, err error) {\n\tversion := ""\n\tif pkg.Version != nil {\n\t\tversion = pkg.Version.String()\n\t}\n\n\tvar metadata *MetadataSpec\n\t// Don\'t set support pack in meta spec if Parameterization is present because that implictly sets\n\t// SupportPack when reading back in anyway.\n\tsupportPack := pkg.SupportPack && pkg.Parameterization == nil\n\tif pkg.moduleFormat != nil || supportPack {\n\t\tmetadata = &MetadataSpec{SupportPack: supportPack}\n\t\tif pkg.moduleFormat != nil {\n\t\t\tmetadata.ModuleFormat = pkg.moduleFormat.String()\n\t\t}\n\t}\n\n\tvar parameterization *ParameterizationSpec\n\tif pkg.Parameterization != nil {\n\t\tparameterization = &ParameterizationSpec{\n\t\t\tBaseProvider: BaseProviderSpec{\n\t\t\t\tName:    pkg.Parameterization.BaseProvider.Name,\n\t\t\t\tVersion: pkg.Parameterization.BaseProvider.Version.String(),\n\t\t\t},\n\t\t\tParameter: pkg.Parameterization.Parameter,\n\t\t}\n\t}\n\n\tspec = &PackageSpec{\n\t\tName:                pkg.Name,\n\t\tVersion:             version,\n\t\tDisplayName:         pkg.DisplayName,\n\t\tPublisher:           pkg.Publisher,\n\t\tNamespace:           pkg.Namespace,\n\t\tDescription:         pkg.Description,\n\t\tKeywords:            pkg.Keywords,\n\t\tHomepage:            pkg.Homepage,\n\t\tLicense:             pkg.License,\n\t\tAttribution:         pkg.Attribution,\n\t\tRepository:          pkg.Repository,\n\t\tLogoURL:             pkg.LogoURL,\n\t\tPluginDownloadURL:   pkg.PluginDownloadURL,\n\t\tMeta:                metadata,\n\t\tDependencies:        pkg.Dependencies,\n\t\tTypes:               map[string]ComplexTypeSpec{},\n\t\tResources:           map[string]ResourceSpec{},\n\t\tFunctions:           map[string]FunctionSpec{},\n\t\tAllowedPackageNames: pkg.AllowedPackageNames,\n\t\tParameterization:    parameterization,\n\t}\n\n\tlang, err := marshalLanguage(pkg.Language)\n\tif err != nil {\n\t\treturn nil, fmt.Errorf("marshaling package language: %w", err)\n\t}\n\tspec.Language = lang\n\n\tspec.Config.Required, spec.Config.Variables, err = pkg.marshalProperties(pkg.Config, true)\n\tif err != nil {\n\t\treturn nil, fmt.Errorf("marshaling package config: %w", err)\n\t}\n\n\tspec.Provider, err = pkg.marshalResource(pkg.Provider)\n\tif err != nil {\n\t\treturn nil, fmt.Errorf("marshaling provider: %w", err)\n\t}\n\n\tfor _, t := range pkg.Types {\n\t\tswitch t := t.(type) {\n\t\tcase *ObjectType:\n\t\t\tif t.IsInputShape() {\n\t\t\t\tcontinue\n\t\t\t}\n\n\t\t\t// Use the input shape when marshaling in order to get the plain annotations right.\n\t\t\to, err := pkg.marshalObject(t.InputShape, false)\n\t\t\tif err != nil {\n\t\t\t\treturn nil, fmt.Errorf("marshaling type \'%v\': %w", t.Token, err)\n\t\t\t}\n\t\t\tspec.Types[t.Token] = o\n\t\tcase *EnumType:\n\t\t\tspec.Types[t.Token] = pkg.marshalEnum(t)\n\t\t}\n\t}\n\n\tfor _, res := range pkg.Resources {\n\t\tr, err := pkg.marshalResource(res)\n\t\tif err != nil {\n\t\t\treturn nil, fmt.Errorf("marshaling resource \'%v\': %w", res.Token, err)\n\t\t}\n\t\tspec.Resources[res.Token] = r\n\t}\n\n\tfor _, fn := range pkg.Functions {\n\t\tf, err := pkg.marshalFunction(fn)\n\t\tif err != nil {\n\t\t\treturn nil, fmt.Errorf("marshaling function \'%v\': %w", fn.Token, err)\n\t\t}\n\t\tspec.Functions[fn.Token] = f\n\t}\n\n\treturn spec, nil\n}\n\nfunc (pkg *Package) MarshalJSON() ([]byte, error) {\n\tspec, err := pkg.MarshalSpec()\n\tif err != nil {\n\t\treturn nil, err\n\t}\n\treturn jsonMarshal(spec)\n}\n\nfunc (pkg *Package) MarshalYAML() ([]byte, error) {\n\tspec, err := pkg.MarshalSpec()\n\tif err != nil {\n\t\treturn nil, err\n\t}\n\n\tvar b bytes.Buffer\n\tenc := yaml.NewEncoder(&b)\n\tenc.SetIndent(2)\n\tif err := enc.Encode(spec); err != nil {\n\t\treturn nil, err\n\t}\n\treturn b.Bytes(), nil\n}\n\nfunc (pkg *Package) marshalObjectData(comment string, properties []*Property, language map[string]any,\n\tplain, isOverlay bool, overlaySupportedLanguages []string,\n) (ObjectTypeSpec, error) {\n\trequired, props, err := pkg.marshalProperties(properties, plain)\n\tif err != nil {\n\t\treturn ObjectTypeSpec{}, err\n\t}\n\n\tlang, err := marshalLanguage(language)\n\tif err != nil {\n\t\treturn ObjectTypeSpec{}, err\n\t}\n\n\treturn ObjectTypeSpec{\n\t\tDescription:               comment,\n\t\tProperties:                props,\n\t\tType:                      "object",\n\t\tRequired:                  required,\n\t\tLanguage:                  lang,\n\t\tIsOverlay:                 isOverlay,\n\t\tOverlaySupportedLanguages: overlaySupportedLanguages,\n\t}, nil\n}\n\nfunc (pkg *Package) marshalObject(t *ObjectType, plain bool) (ComplexTypeSpec, error) {\n\tdata, err := pkg.marshalObjectData(t.Comment, t.Properties, t.Language, plain, t.IsOverlay, nil)\n\tif err != nil {\n\t\treturn ComplexTypeSpec{}, err\n\t}\n\treturn ComplexTypeSpec{ObjectTypeSpec: data}, nil\n}\n\nfunc (pkg *Package) marshalEnum(t *EnumType) ComplexTypeSpec {\n\tvalues := make([]EnumValueSpec, len(t.Elements))\n\tfor i, el := range t.Elements {\n\t\tvalues[i] = EnumValueSpec{\n\t\t\tName:               el.Name,\n\t\t\tDescription:        el.Comment,\n\t\t\tValue:              el.Value,\n\t\t\tDeprecationMessage: el.DeprecationMessage,\n\t\t}\n\t}\n\n\treturn ComplexTypeSpec{\n\t\tObjectTypeSpec: ObjectTypeSpec{\n\t\t\tDescription: t.Comment,\n\t\t\tType:        pkg.marshalType(t.ElementType, false).Type,\n\t\t\tIsOverlay:   t.IsOverlay,\n\t\t},\n\t\tEnum: values,\n\t}\n}\n\nfunc (pkg *Package) marshalResource(r *Resource) (ResourceSpec, error) {\n\tobject, err := pkg.marshalObjectData(r.Comment, r.Properties, r.Language, true, r.IsOverlay,\n\t\tr.OverlaySupportedLanguages)\n\tif err != nil {\n\t\treturn ResourceSpec{}, fmt.Errorf("marshaling properties: %w", err)\n\t}\n\n\trequiredInputs, inputs, err := pkg.marshalProperties(r.InputProperties, false)\n\tif err != nil {\n\t\treturn ResourceSpec{}, fmt.Errorf("marshaling input properties: %w", err)\n\t}\n\n\tvar stateInputs *ObjectTypeSpec\n\tif r.StateInputs != nil {\n\t\to, err := pkg.marshalObject(r.StateInputs, false)\n\t\tif err != nil {\n\t\t\treturn ResourceSpec{}, fmt.Errorf("marshaling state inputs: %w", err)\n\t\t}\n\t\tstateInputs = &o.ObjectTypeSpec\n\t}\n\n\taliases := slice.Prealloc[AliasSpec](len(r.Aliases))\n\tfor _, a := range r.Aliases {\n\t\taliases = append(aliases, AliasSpec{\n\t\t\tcompatibility: a.compatibility,\n\t\t\tType:          a.Type,\n\t\t})\n\t}\n\n\tvar methods map[string]string\n\tif len(r.Methods) != 0 {\n\t\tmethods = map[string]string{}\n\t\tfor _, m := range r.Methods {\n\t\t\tmethods[m.Name] = m.Function.Token\n\t\t}\n\t}\n\n\treturn ResourceSpec{\n\t\tObjectTypeSpec:     object,\n\t\tInputProperties:    inputs,\n\t\tRequiredInputs:     requiredInputs,\n\t\tStateInputs:        stateInputs,\n\t\tAliases:            aliases,\n\t\tDeprecationMessage: r.DeprecationMessage,\n\t\tIsComponent:        r.IsComponent,\n\t\tMethods:            methods,\n\t}, nil\n}\n\nfunc (pkg *Package) marshalFunction(f *Function) (FunctionSpec, error) {\n\tvar inputs *ObjectTypeSpec\n\tif f.Inputs != nil {\n\t\tins, err := pkg.marshalObject(f.Inputs, true)\n\t\tif err != nil {\n\t\t\treturn FunctionSpec{}, fmt.Errorf("marshaling inputs: %w", err)\n\t\t}\n\t\tinputs = &ins.ObjectTypeSpec\n\t}\n\tvar multiArgumentInputs []string\n\tif f.MultiArgumentInputs {\n\t\tmultiArgumentInputs = make([]string, len(f.Inputs.Properties))\n\t\tfor i, prop := range f.Inputs.Properties {\n\t\t\tmultiArgumentInputs[i] = prop.Name\n\t\t}\n\t}\n\n\tvar outputs *ObjectTypeSpec\n\tif f.Outputs != nil {\n\t\touts, err := pkg.marshalObject(f.Outputs, true)\n\t\tif err != nil {\n\t\t\treturn FunctionSpec{}, fmt.Errorf("marshaling outputs: %w", err)\n\t\t}\n\t\toutputs = &outs.ObjectTypeSpec\n\t}\n\n\tvar returnType *ReturnTypeSpec\n\tif f.ReturnType != nil {\n\t\treturnType = &ReturnTypeSpec{}\n\t\tif objectType, ok := f.ReturnType.(*ObjectType); ok {\n\t\t\tret, err := pkg.marshalObject(objectType, true)\n\t\t\tif err != nil {\n\t\t\t\treturn FunctionSpec{}, fmt.Errorf("marshaling object spec: %w", err)\n\t\t\t}\n\t\t\treturnType.ObjectTypeSpec = &ret.ObjectTypeSpec\n\t\t\tif f.ReturnTypePlain {\n\t\t\t\treturnType.ObjectTypeSpecIsPlain = true\n\t\t\t}\n\t\t} else {\n\t\t\ttypeSpec := pkg.marshalType(f.ReturnType, true)\n\t\t\treturnType.TypeSpec = &typeSpec\n\t\t\tif f.ReturnTypePlain {\n\t\t\t\treturnType.TypeSpec.Plain = true\n\t\t\t}\n\t\t}\n\t}\n\n\tlang, err := marshalLanguage(f.Language)\n\tif err != nil {\n\t\treturn FunctionSpec{}, err\n\t}\n\n\treturn FunctionSpec{\n\t\tDescription:               f.Comment,\n\t\tDeprecationMessage:        f.DeprecationMessage,\n\t\tIsOverlay:                 f.IsOverlay,\n\t\tOverlaySupportedLanguages: f.OverlaySupportedLanguages,\n\t\tInputs:                    inputs,\n\t\tMultiArgumentInputs:       multiArgumentInputs,\n\t\tOutputs:                   outputs,\n\t\tReturnType:                returnType,\n\t\tLanguage:                  lang,\n\t}, nil\n}\n\nfunc (pkg *Package) marshalProperties(props []*Property, plain bool) (required []string, specs map[string]PropertySpec,\n\terr error,\n) {\n\tif len(props) == 0 {\n\t\treturn required, specs, err\n\t}\n\n\tspecs = make(map[string]PropertySpec, len(props))\n\tfor _, p := range props {\n\t\ttyp := p.Type\n\t\tif t, optional := typ.(*OptionalType); optional {\n\t\t\ttyp = t.ElementType\n\t\t} else {\n\t\t\trequired = append(required, p.Name)\n\t\t}\n\n\t\tvar defaultValue any\n\t\tvar defaultSpec *DefaultSpec\n\t\tif p.DefaultValue != nil {\n\t\t\tdefaultValue = p.DefaultValue.Value\n\t\t\tif len(p.DefaultValue.Environment) != 0 || len(p.DefaultValue.Language) != 0 {\n\t\t\t\tlang, err := marshalLanguage(p.DefaultValue.Language)\n\t\t\t\tif err != nil {\n\t\t\t\t\treturn nil, nil, fmt.Errorf("property \'%v\': %w", p.Name, err)\n\t\t\t\t}\n\n\t\t\t\tdefaultSpec = &DefaultSpec{\n\t\t\t\t\tEnvironment: p.DefaultValue.Environment,\n\t\t\t\t\tLanguage:    lang,\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\n\t\tlang, err := marshalLanguage(p.Language)\n\t\tif err != nil {\n\t\t\treturn nil, nil, fmt.Errorf("property \'%v\': %w", p.Name, err)\n\t\t}\n\n\t\tpropertyType := pkg.marshalType(typ, plain)\n\t\tpropertyType.Plain = p.Plain\n\t\tspecs[p.Name] = PropertySpec{\n\t\t\tTypeSpec:             propertyType,\n\t\t\tDescription:          p.Comment,\n\t\t\tConst:                p.ConstValue,\n\t\t\tDefault:              defaultValue,\n\t\t\tDefaultInfo:          defaultSpec,\n\t\t\tDeprecationMessage:   p.DeprecationMessage,\n\t\t\tLanguage:             lang,\n\t\t\tSecret:               p.Secret,\n\t\t\tReplaceOnChanges:     p.ReplaceOnChanges,\n\t\t\tWillReplaceOnChanges: p.WillReplaceOnChanges,\n\t\t}\n\t}\n\treturn required, specs, nil\n}\n\n// marshalType marshals the given type into a TypeSpec. If plain is true, then the type is being marshaled within a\n// plain type context (e.g. a resource output property or a function input/output object type), and therefore does not\n// require `Plain` annotations (hence the odd-looking `Plain: !plain` fields below).\nfunc (pkg *Package) marshalType(t Type, plain bool) TypeSpec {\n\tswitch t := t.(type) {\n\tcase *InputType:\n\t\tel := pkg.marshalType(t.ElementType, false)\n\t\tel.Plain = false\n\t\treturn el\n\tcase *ArrayType:\n\t\tel := pkg.marshalType(t.ElementType, plain)\n\t\treturn TypeSpec{\n\t\t\tType:  "array",\n\t\t\tItems: &el,\n\t\t\tPlain: !plain,\n\t\t}\n\tcase *MapType:\n\t\tel := pkg.marshalType(t.ElementType, plain)\n\t\treturn TypeSpec{\n\t\t\tType:                 "object",\n\t\t\tAdditionalProperties: &el,\n\t\t\tPlain:                !plain,\n\t\t}\n\tcase *UnionType:\n\t\toneOf := make([]TypeSpec, len(t.ElementTypes))\n\t\tfor i, el := range t.ElementTypes {\n\t\t\toneOf[i] = pkg.marshalType(el, plain)\n\t\t}\n\n\t\tdefaultType := ""\n\t\tif t.DefaultType != nil {\n\t\t\tdefaultType = pkg.marshalType(t.DefaultType, plain).Type\n\t\t}\n\n\t\tvar discriminator *DiscriminatorSpec\n\t\tif t.Discriminator != "" {\n\t\t\tdiscriminator = &DiscriminatorSpec{\n\t\t\t\tPropertyName: t.Discriminator,\n\t\t\t\tMapping:      t.Mapping,\n\t\t\t}\n\t\t}\n\n\t\treturn TypeSpec{\n\t\t\tType:          defaultType,\n\t\t\tOneOf:         oneOf,\n\t\t\tDiscriminator: discriminator,\n\t\t\tPlain:         !plain,\n\t\t}\n\tcase *ObjectType:\n\t\treturn TypeSpec{\n\t\t\tRef:   pkg.marshalTypeRef(t.PackageReference, "types", t.Token),\n\t\t\tPlain: !plain,\n\t\t}\n\tcase *EnumType:\n\t\treturn TypeSpec{\n\t\t\tRef:   pkg.marshalTypeRef(t.PackageReference, "types", t.Token),\n\t\t\tPlain: !plain,\n\t\t}\n\tcase *ResourceType:\n\t\treturn TypeSpec{\n\t\t\tRef:   pkg.marshalTypeRef(t.Resource.PackageReference, "resources", t.Token),\n\t\t\tPlain: !plain,\n\t\t}\n\tcase *TokenType:\n\t\tvar defaultType string\n\t\tif t.UnderlyingType != nil {\n\t\t\tdefaultType = pkg.marshalType(t.UnderlyingType, plain).Type\n\t\t}\n\n\t\treturn TypeSpec{\n\t\t\tType:  defaultType,\n\t\t\tRef:   pkg.marshalTypeRef(pkg.Reference(), "types", t.Token),\n\t\t\tPlain: !plain,\n\t\t}\n\tdefault:\n\t\tswitch t {\n\t\tcase BoolType:\n\t\t\treturn TypeSpec{\n\t\t\t\tType:  "boolean",\n\t\t\t\tPlain: !plain,\n\t\t\t}\n\t\tcase StringType:\n\t\t\treturn TypeSpec{\n\t\t\t\tType:  "string",\n\t\t\t\tPlain: !plain,\n\t\t\t}\n\t\tcase IntType:\n\t\t\treturn TypeSpec{\n\t\t\t\tType:  "integer",\n\t\t\t\tPlain: !plain,\n\t\t\t}\n\t\tcase NumberType:\n\t\t\treturn TypeSpec{\n\t\t\t\tType:  "number",\n\t\t\t\tPlain: !plain,\n\t\t\t}\n\t\tcase AnyType:\n\t\t\treturn TypeSpec{\n\t\t\t\tRef:   "pulumi.json#/Any",\n\t\t\t\tPlain: !plain,\n\t\t\t}\n\t\tcase ArchiveType:\n\t\t\treturn TypeSpec{\n\t\t\t\tRef:   "pulumi.json#/Archive",\n\t\t\t\tPlain: !plain,\n\t\t\t}\n\t\tcase AssetType:\n\t\t\treturn TypeSpec{\n\t\t\t\tRef:   "pulumi.json#/Asset",\n\t\t\t\tPlain: !plain,\n\t\t\t}\n\t\tcase JSONType:\n\t\t\treturn TypeSpec{\n\t\t\t\tRef:   "pulumi.json#/Json",\n\t\t\t\tPlain: !plain,\n\t\t\t}\n\t\tdefault:\n\t\t\tpanic(fmt.Errorf("unexepcted type %v (%T)", t, t))\n\t\t}\n\t}\n}\n\nfunc (pkg *Package) marshalTypeRef(container PackageReference, section, token string) string {\n\ttoken = url.PathEscape(token)\n\n\tif p, err := container.Definition(); err == nil && p == pkg {\n\t\treturn fmt.Sprintf("#/%s/%s", section, token)\n\t}\n\n\t// TODO(schema): this isn\'t quite right--it doesn\'t handle schemas sourced from URLs--but it\'s good enough for now.\n\treturn fmt.Sprintf("/%s/v%v/schema.json#/%s/%s", container.Name(), container.Version(), section, token)\n}\n\nfunc marshalLanguage(lang map[string]any) (map[string]RawMessage, error) {\n\tif len(lang) == 0 {\n\t\treturn nil, nil\n\t}\n\n\tresult := map[string]RawMessage{}\n\tfor name, data := range lang {\n\t\tbytes, err := jsonMarshal(data)\n\t\tif err != nil {\n\t\t\treturn nil, fmt.Errorf("marshaling %v language data: %w", name, err)\n\t\t}\n\t\tresult[name] = RawMessage(bytes)\n\t}\n\treturn result, nil\n}\n\nfunc jsonMarshal(v any) ([]byte, error) {\n\tvar b bytes.Buffer\n\tenc := json.NewEncoder(&b)\n\tenc.SetEscapeHTML(false)\n\tenc.SetIndent("", "  ")\n\tif err := enc.Encode(v); err != nil {\n\t\treturn nil, err\n\t}\n\treturn b.Bytes(), nil\n}\n\ntype RawMessage []byte\n\nfunc (m RawMessage) MarshalJSON() ([]byte, error) {\n\treturn []byte(m), nil\n}\n\nfunc (m *RawMessage) UnmarshalJSON(bytes []byte) error {\n\t*m = make([]byte, len(bytes))\n\tcopy(*m, bytes)\n\treturn nil\n}\n\nfunc (m RawMessage) MarshalYAML() ([]byte, error) {\n\treturn []byte(m), nil\n}\n\nfunc (m *RawMessage) UnmarshalYAML(node *yaml.Node) error {\n\tvar value any\n\tif err := node.Decode(&value); err != nil {\n\t\treturn err\n\t}\n\tbytes, err := jsonMarshal(value)\n\tif err != nil {\n\t\treturn err\n\t}\n\t*m = bytes\n\treturn nil\n}\n\n// TypeSpec is the serializable form of a reference to a type.\ntype TypeSpec struct {\n\t// Type is the primitive or composite type, if any. May be "boolean", "string", "integer", "number", "array", or\n\t// "object".\n\tType string `json:"type,omitempty" yaml:"type,omitempty"`\n\t// Ref is a reference to a type in this or another document. For example, the built-in Archive, Asset, and Any\n\t// types are referenced as "pulumi.json#/Archive", "pulumi.json#/Asset", and "pulumi.json#/Any", respectively.\n\t// A type from this document is referenced as "#/types/pulumi:type:token".\n\t// A type from another document is referenced as "path#/types/pulumi:type:token", where path is of the form:\n\t//   "/provider/vX.Y.Z/schema.json" or "pulumi.json" or "http[s]://example.com/provider/vX.Y.Z/schema.json"\n\t// A resource from this document is referenced as "#/resources/pulumi:type:token".\n\t// A resource from another document is referenced as "path#/resources/pulumi:type:token", where path is of the form:\n\t//   "/provider/vX.Y.Z/schema.json" or "pulumi.json" or "http[s]://example.com/provider/vX.Y.Z/schema.json"\n\tRef string `json:"$ref,omitempty" yaml:"$ref,omitempty"`\n\t// AdditionalProperties, if set, describes the element type of an "object" (i.e. a string -> value map).\n\tAdditionalProperties *TypeSpec `json:"additionalProperties,omitempty" yaml:"additionalProperties,omitempty"`\n\t// Items, if set, describes the element type of an array.\n\tItems *TypeSpec `json:"items,omitempty" yaml:"items,omitempty"`\n\t// OneOf indicates that values of the type may be one of any of the listed types.\n\tOneOf []TypeSpec `json:"oneOf,omitempty" yaml:"oneOf,omitempty"`\n\t// Discriminator informs the consumer of an alternative schema based on the value associated with it.\n\tDiscriminator *DiscriminatorSpec `json:"discriminator,omitempty" yaml:"discriminator,omitempty"`\n\t// Plain indicates that when used as an input, this type does not accept eventual values.\n\tPlain bool `json:"plain,omitempty" yaml:"plain,omitempty"`\n}\n\n// DiscriminatorSpec informs the consumer of an alternative schema based on the value associated with it.\ntype DiscriminatorSpec struct {\n\t// PropertyName is the name of the property in the payload that will hold the discriminator value.\n\tPropertyName string `json:"propertyName" yaml:"propertyName"`\n\t// Mapping is an optional object to hold mappings between payload values and schema names or references.\n\tMapping map[string]string `json:"mapping,omitempty" yaml:"mapping,omitempty"`\n}\n\n// DefaultSpec is the serializable form of extra information about the default value for a property.\ntype DefaultSpec struct {\n\t// Environment specifies a set of environment variables to probe for a default value.\n\tEnvironment []string `json:"environment,omitempty" yaml:"environment,omitempty"`\n\t// Language specifies additional language-specific data about the default value.\n\tLanguage map[string]RawMessage `json:"language,omitempty" yaml:"language,omitempty"`\n}\n\n// PropertySpec is the serializable form of an object or resource property.\ntype PropertySpec struct {\n\tTypeSpec `yaml:",inline"`\n\n\t// Description is the description of the property, if any.\n\tDescription string `json:"description,omitempty" yaml:"description,omitempty"`\n\t// Const is the constant value for the property, if any. The type of the value must be assignable to the type of\n\t// the property.\n\tConst any `json:"const,omitempty" yaml:"const,omitempty"`\n\t// Default is the default value for the property, if any. The type of the value must be assignable to the type of\n\t// the property.\n\tDefault any `json:"default,omitempty" yaml:"default,omitempty"`\n\t// DefaultInfo contains additional information about the property\'s default value, if any.\n\tDefaultInfo *DefaultSpec `json:"defaultInfo,omitempty" yaml:"defaultInfo,omitempty"`\n\t// DeprecationMessage indicates whether or not the property is deprecated.\n\tDeprecationMessage string `json:"deprecationMessage,omitempty" yaml:"deprecationMessage,omitempty"`\n\t// Language specifies additional language-specific data about the property.\n\tLanguage map[string]RawMessage `json:"language,omitempty" yaml:"language,omitempty"`\n\t// Secret specifies if the property is secret (default false).\n\tSecret bool `json:"secret,omitempty" yaml:"secret,omitempty"`\n\t// ReplaceOnChanges specifies if the property is to be replaced instead of updated (default false).\n\tReplaceOnChanges bool `json:"replaceOnChanges,omitempty" yaml:"replaceOnChanges,omitempty"`\n\t// WillReplaceOnChanges indicates that the provider will replace the resource when\n\t// this property is changed. This property is used exclusively for docs.\n\tWillReplaceOnChanges bool `json:"willReplaceOnChanges,omitempty" yaml:"willReplaceOnChanges,omitempty"`\n}\n\n// ObjectTypeSpec is the serializable form of an object type.\ntype ObjectTypeSpec struct {\n\t// Description is the description of the type, if any.\n\tDescription string `json:"description,omitempty" yaml:"description,omitempty"`\n\t// Properties, if present, is a map from property name to PropertySpec that describes the type\'s properties.\n\tProperties map[string]PropertySpec `json:"properties,omitempty" yaml:"properties,omitempty"`\n\t// Type must be "object" if this is an object type, or the underlying type for an enum.\n\tType string `json:"type,omitempty" yaml:"type,omitempty"`\n\t// Required, if present, is a list of the names of an object type\'s required properties. These properties must be set\n\t// for inputs and will always be set for outputs.\n\tRequired []string `json:"required,omitempty" yaml:"required,omitempty"`\n\t// Plain, was a list of the names of an object type\'s plain properties. This property is ignored: instead, property\n\t// types should be marked as plain where necessary.\n\tPlain []string `json:"plain,omitempty" yaml:"plain,omitempty"`\n\t// Language specifies additional language-specific data about the type.\n\tLanguage map[string]RawMessage `json:"language,omitempty" yaml:"language,omitempty"`\n\t// IsOverlay indicates whether the type is an overlay provided by the package. Overlay code is generated by the\n\t// package rather than using the core Pulumi codegen libraries.\n\tIsOverlay bool `json:"isOverlay,omitempty" yaml:"isOverlay,omitempty"`\n\t// OverlaySupportedLanguages indicates what languages the overlay supports. This only has an effect if\n\t// the Resource is an Overlay (IsOverlay == true).\n\t// Supported values are "nodejs", "python", "go", "csharp", "java", "yaml"\n\tOverlaySupportedLanguages []string `json:"overlaySupportedLanguages,omitempty" yaml:"overlaySupportedLanguages,omitempty"` //nolint:lll\n}\n\n// ComplexTypeSpec is the serializable form of an object or enum type.\ntype ComplexTypeSpec struct {\n\tObjectTypeSpec `yaml:",inline"`\n\n\t// Enum, if present, is the list of possible values for an enum type.\n\tEnum []EnumValueSpec `json:"enum,omitempty" yaml:"enum,omitempty"`\n}\n\n// EnumValueSpec is the serializable form of the values metadata associated with an enum type.\ntype EnumValueSpec struct {\n\t// Name, if present, overrides the name of the enum value that would usually be derived from the value.\n\tName string `json:"name,omitempty" yaml:"name,omitempty"`\n\t// Description of the enum value.\n\tDescription string `json:"description,omitempty" yaml:"description,omitempty"`\n\t// Value is the enum value itself.\n\tValue any `json:"value" yaml:"value"`\n\t// DeprecationMessage indicates whether or not the value is deprecated.\n\tDeprecationMessage string `json:"deprecationMessage,omitempty" yaml:"deprecationMessage,omitempty"`\n}\n\n// AliasSpec is the serializable form of an alias description.\ntype AliasSpec struct {\n\t// Type is the type portion of the alias, if any.\n\tType string `json:"type,omitempty" yaml:"type,omitempty"`\n\n\t// This is set by the marshaller to indicate that the alias is a string, and to write it back as one.\n\tcompatibility bool\n}\n\n// AliasSpec can marshal from just a string\nfunc (a *AliasSpec) UnmarshalJSON(data []byte) error {\n\tvar s string\n\terr := json.Unmarshal(data, &s)\n\tif err == nil {\n\t\ta.Type = s\n\t\ta.compatibility = true\n\t\treturn nil\n\t}\n\tvar o struct {\n\t\tType string `json:"type"`\n\t}\n\terr = json.Unmarshal(data, &o)\n\tif err == nil {\n\t\ta.Type = o.Type\n\t\treturn nil\n\t}\n\treturn err\n}\n\n// AliasSpec can marshal to just a string\nfunc (a AliasSpec) MarshalJSON() ([]byte, error) {\n\tif a.compatibility {\n\t\treturn json.Marshal(a.Type)\n\t}\n\tvar o struct {\n\t\tType string `json:"type"`\n\t}\n\to.Type = a.Type\n\treturn json.Marshal(&o)\n}\n\n// AliasSpec can unmarshal from just a string\nfunc (a *AliasSpec) UnmarshalYAML(node *yaml.Node) error {\n\tvar s string\n\terr := node.Decode(&s)\n\tif err == nil {\n\t\ta.Type = s\n\t\ta.compatibility = true\n\t\treturn nil\n\t}\n\tvar o struct {\n\t\tType string `yaml:"type"`\n\t}\n\terr = node.Decode(&o)\n\tif err == nil {\n\t\ta.Type = o.Type\n\t\treturn nil\n\t}\n\treturn err\n}\n\n// AliasSpec can marshal to just a string\nfunc (a AliasSpec) MarshalYAML() (any, error) {\n\tif a.compatibility {\n\t\treturn a.Type, nil\n\t}\n\tvar o struct {\n\t\tType string `yaml:"type"`\n\t}\n\to.Type = a.Type\n\treturn o, nil\n}\n\n// ResourceSpec is the serializable form of a resource description.\ntype ResourceSpec struct {\n\tObjectTypeSpec `yaml:",inline"`\n\n\t// InputProperties is a map from property name to PropertySpec that describes the resource\'s input properties.\n\tInputProperties map[string]PropertySpec `json:"inputProperties,omitempty" yaml:"inputProperties,omitempty"`\n\t// RequiredInputs is a list of the names of the resource\'s required input properties.\n\tRequiredInputs []string `json:"requiredInputs,omitempty" yaml:"requiredInputs,omitempty"`\n\t// PlainInputs was a list of the names of the resource\'s plain input properties. This property is ignored:\n\t// instead, property types should be marked as plain where necessary.\n\tPlainInputs []string `json:"plainInputs,omitempty" yaml:"plainInputs,omitempty"`\n\t// StateInputs is an optional ObjectTypeSpec that describes additional inputs that may be necessary to get an\n\t// existing resource. If this is unset, only an ID is necessary.\n\tStateInputs *ObjectTypeSpec `json:"stateInputs,omitempty" yaml:"stateInputs,omitempty"`\n\t// Aliases is the list of aliases for the resource. This can either be a list of strings or a list of objects with\n\t// type fields.\n\tAliases []AliasSpec `json:"aliases,omitempty" yaml:"aliases,omitempty"`\n\t// DeprecationMessage indicates whether or not the resource is deprecated.\n\tDeprecationMessage string `json:"deprecationMessage,omitempty" yaml:"deprecationMessage,omitempty"`\n\t// IsComponent indicates whether the resource is a ComponentResource.\n\tIsComponent bool `json:"isComponent,omitempty" yaml:"isComponent,omitempty"`\n\t// Methods maps method names to functions in this schema.\n\tMethods map[string]string `json:"methods,omitempty" yaml:"methods,omitempty"`\n}\n\n// ReturnTypeSpec is either ObjectTypeSpec or TypeSpec.\ntype ReturnTypeSpec struct {\n\tObjectTypeSpec *ObjectTypeSpec\n\n\t// If ObjectTypeSpec is non-nil, it can also be marked with ObjectTypeSpecIsPlain: true\n\t// indicating that the generated code should not wrap in the result in an Output but return\n\t// it directly. This option is incompatible with marking individual properties with\n\t// ObjectTypSpec.Plain.\n\tObjectTypeSpecIsPlain bool\n\n\tTypeSpec *TypeSpec\n}\n\ntype returnTypeSpecObjectSerialForm struct {\n\tObjectTypeSpec\n\tPlain any `json:"plain,omitempty"`\n}\n\nfunc (returnTypeSpec *ReturnTypeSpec) marshalJSONLikeObject() (map[string]any, error) {\n\tts := returnTypeSpec\n\tbytes, err := ts.MarshalJSON()\n\tif err != nil {\n\t\treturn nil, err\n\t}\n\tvar r map[string]any\n\tif err := json.Unmarshal(bytes, &r); err != nil {\n\t\treturn nil, err\n\t}\n\treturn r, nil\n}\n\nfunc (returnTypeSpec *ReturnTypeSpec) MarshalJSON() ([]byte, error) {\n\tts := returnTypeSpec\n\tif ts.ObjectTypeSpec != nil {\n\t\tform := returnTypeSpecObjectSerialForm{\n\t\t\tObjectTypeSpec: *ts.ObjectTypeSpec,\n\t\t}\n\t\tif ts.ObjectTypeSpecIsPlain {\n\t\t\tform.Plain = true\n\t\t} else if len(ts.ObjectTypeSpec.Plain) > 0 {\n\t\t\tform.Plain = ts.ObjectTypeSpec.Plain\n\t\t}\n\t\treturn json.Marshal(form)\n\t}\n\treturn json.Marshal(ts.TypeSpec)\n}\n\nfunc (returnTypeSpec *ReturnTypeSpec) UnmarshalJSON(inputJSON []byte) error {\n\tts := returnTypeSpec\n\tvar m returnTypeSpecObjectSerialForm\n\terr := json.Unmarshal(inputJSON, &m)\n\tif err == nil {\n\t\tif m.Properties != nil {\n\t\t\tts.ObjectTypeSpec = &m.ObjectTypeSpec\n\t\t\tif plain, ok := m.Plain.(bool); ok && plain {\n\t\t\t\tts.ObjectTypeSpecIsPlain = true\n\t\t\t}\n\t\t\tif plain, ok := m.Plain.([]any); ok {\n\t\t\t\tfor _, p := range plain {\n\t\t\t\t\tif ps, ok := p.(string); ok {\n\t\t\t\t\t\tts.ObjectTypeSpec.Plain = append(ts.ObjectTypeSpec.Plain, ps)\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t\treturn nil\n\t\t}\n\t}\n\n\treturn json.Unmarshal(inputJSON, &ts.TypeSpec)\n}\n\n// Deprecated.\ntype Decoder func([]byte, any) error\n\n// Deprecated.\nfunc (returnTypeSpec *ReturnTypeSpec) UnmarshalReturnTypeSpec(data []byte, decode Decoder) error {\n\tvar objectMap map[string]any\n\tif err := decode(data, &objectMap); err != nil {\n\t\treturn err\n\t}\n\tif len(objectMap) == 0 {\n\t\treturn nil\n\t}\n\tinputJSON, err := json.Marshal(objectMap)\n\tif err != nil {\n\t\treturn err\n\t}\n\treturn returnTypeSpec.UnmarshalJSON(inputJSON)\n}\n\n// Deprecated.\nfunc (returnTypeSpec *ReturnTypeSpec) UnmarshalYAML(inputYAML []byte) error {\n\treturn returnTypeSpec.UnmarshalReturnTypeSpec(inputYAML, yaml.Unmarshal)\n}\n\n// FunctionSpec is the serializable form of a function description.\ntype FunctionSpec struct {\n\t// Description is the description of the function, if any.\n\tDescription string `json:"description,omitempty" yaml:"description,omitempty"`\n\t// Inputs is the bag of input values for the function, if any.\n\tInputs *ObjectTypeSpec `json:"inputs,omitempty" yaml:"inputs,omitempty"`\n\t// Determines whether the input bag should be treated as a single argument or as multiple arguments.\n\t// When MultiArgumentInputs is non-empty, it must match up 1:1 with the property names in of the Inputs object.\n\t// The order in which the properties are listed in MultiArgumentInputs determines the order in which the\n\t// arguments are passed to the function.\n\tMultiArgumentInputs []string `json:"multiArgumentInputs,omitempty" yaml:"multiArgumentInputs,omitempty"`\n\t// Outputs is the bag of output values for the function, if any.\n\t// This field is DEPRECATED. Use ReturnType instead where it allows for more flexible types\n\t// to describe the outputs of the function definition. It is invalid to specify both Outputs and ReturnType.\n\tOutputs *ObjectTypeSpec `json:"outputs,omitempty" yaml:"outputs,omitempty"`\n\t// Specified the return type of the function definition\n\tReturnType *ReturnTypeSpec\n\t// DeprecationMessage indicates whether the function is deprecated.\n\tDeprecationMessage string `json:"deprecationMessage,omitempty" yaml:"deprecationMessage,omitempty"`\n\t// Language specifies additional language-specific data about the function.\n\tLanguage map[string]RawMessage `json:"language,omitempty" yaml:"language,omitempty"`\n\t// IsOverlay indicates whether the function is an overlay provided by the package. Overlay code is generated by the\n\t// package rather than using the core Pulumi codegen libraries.\n\tIsOverlay bool `json:"isOverlay,omitempty" yaml:"isOverlay,omitempty"`\n\t// OverlaySupportedLanguages indicates what languages the overlay supports. This only has an effect if\n\t// the Resource is an Overlay (IsOverlay == true).\n\t// Supported values are "nodejs", "python", "go", "csharp", "java", "yaml"\n\tOverlaySupportedLanguages []string `json:"overlaySupportedLanguages,omitempty" yaml:"overlaySupportedLanguages,omitempty"` //nolint:lll\n}\n\nfunc emptyObject(data RawMessage) (bool, error) {\n\tvar objectData *map[string]RawMessage\n\tif err := json.Unmarshal(data, &objectData); err != nil {\n\t\treturn false, err\n\t}\n\n\tif objectData == nil {\n\t\treturn true, nil\n\t}\n\n\treturn len(*objectData) == 0, nil\n}\n\nfunc unmarshalFunctionSpec(funcSpec *FunctionSpec, data map[string]RawMessage) error {\n\tif description, ok := data["description"]; ok {\n\t\tif err := json.Unmarshal(description, &funcSpec.Description); err != nil {\n\t\t\treturn err\n\t\t}\n\t}\n\n\tif inputs, ok := data["inputs"]; ok {\n\t\tif err := json.Unmarshal(inputs, &funcSpec.Inputs); err != nil {\n\t\t\treturn err\n\t\t}\n\t}\n\n\tif multiArgumentInputs, ok := data["multiArgumentInputs"]; ok {\n\t\tif err := json.Unmarshal(multiArgumentInputs, &funcSpec.MultiArgumentInputs); err != nil {\n\t\t\treturn err\n\t\t}\n\t}\n\n\tif returnType, ok := data["outputs"]; ok {\n\t\tisEmpty, err := emptyObject(returnType)\n\t\tif err != nil {\n\t\t\treturn err\n\t\t}\n\n\t\tif !isEmpty {\n\t\t\tif err := json.Unmarshal(returnType, &funcSpec.ReturnType); err != nil {\n\t\t\t\treturn err\n\t\t\t}\n\t\t} else {\n\t\t\tfuncSpec.ReturnType = nil\n\t\t}\n\t}\n\n\tif deprecationMessage, ok := data["deprecationMessage"]; ok {\n\t\tif err := json.Unmarshal(deprecationMessage, &funcSpec.DeprecationMessage); err != nil {\n\t\t\treturn err\n\t\t}\n\t}\n\n\tif language, ok := data["language"]; ok {\n\t\tif err := json.Unmarshal(language, &funcSpec.Language); err != nil {\n\t\t\treturn err\n\t\t}\n\t}\n\n\tif isOverlay, ok := data["isOverlay"]; ok {\n\t\tif err := json.Unmarshal(isOverlay, &funcSpec.IsOverlay); err != nil {\n\t\t\treturn err\n\t\t}\n\t}\n\n\tif overlaySupportedLanguages, ok := data["overlaySupportedLanguages"]; ok {\n\t\tif err := json.Unmarshal(overlaySupportedLanguages, &funcSpec.OverlaySupportedLanguages); err != nil {\n\t\t\treturn err\n\t\t}\n\t}\n\n\treturn nil\n}\n\n// UnmarshalJSON is custom unmarshalling logic for FunctionSpec so that we can derive Outputs from ReturnType\n// which otherwise isn\'t possible when both are retrieved from the same JSON field\nfunc (funcSpec *FunctionSpec) UnmarshalJSON(inputJSON []byte) error {\n\tvar data map[string]RawMessage\n\tif err := json.Unmarshal(inputJSON, &data); err != nil {\n\t\treturn err\n\t}\n\treturn unmarshalFunctionSpec(funcSpec, data)\n}\n\n// UnmarshalYAML is custom unmarshalling logic for FunctionSpec so that we can derive Outputs from ReturnType\n// which otherwise isn\'t possible when both are retrieved from the same JSON field\nfunc (funcSpec *FunctionSpec) UnmarshalYAML(node *yaml.Node) error {\n\tvar data map[string]RawMessage\n\tif err := node.Decode(&data); err != nil {\n\t\treturn err\n\t}\n\treturn unmarshalFunctionSpec(funcSpec, data)\n}\n\nfunc (funcSpec FunctionSpec) marshalFunctionSpec() (map[string]any, error) {\n\tdata := make(map[string]any)\n\tif funcSpec.Description != "" {\n\t\tdata["description"] = funcSpec.Description\n\t}\n\n\tif funcSpec.Inputs != nil {\n\t\tdata["inputs"] = funcSpec.Inputs\n\t}\n\n\tif len(funcSpec.MultiArgumentInputs) > 0 {\n\t\tdata["multiArgumentInputs"] = funcSpec.MultiArgumentInputs\n\t}\n\n\tif funcSpec.ReturnType != nil {\n\t\trto, err := funcSpec.ReturnType.marshalJSONLikeObject()\n\t\tif err != nil {\n\t\t\treturn nil, err\n\t\t}\n\t\tdata["outputs"] = rto\n\t}\n\n\t// for backward-compat when we only specify the outputs object of the function\n\tif funcSpec.ReturnType == nil && funcSpec.Outputs != nil {\n\t\tdata["outputs"] = funcSpec.Outputs\n\t}\n\n\tif funcSpec.DeprecationMessage != "" {\n\t\tdata["deprecationMessage"] = funcSpec.DeprecationMessage\n\t}\n\n\tif funcSpec.IsOverlay {\n\t\t// the default is false, so only write the property when it is true\n\t\tdata["isOverlay"] = true\n\t}\n\n\tif len(funcSpec.OverlaySupportedLanguages) > 0 {\n\t\t// by default it supports all languages the provider supports, so only write the property when it is not the default\n\t\tdata["overlaySupportedLanguages"] = funcSpec.OverlaySupportedLanguages\n\t}\n\n\tif len(funcSpec.Language) > 0 {\n\t\tdata["language"] = funcSpec.Language\n\t}\n\n\treturn data, nil\n}\n\nfunc (funcSpec FunctionSpec) MarshalJSON() ([]byte, error) {\n\tdata, err := funcSpec.marshalFunctionSpec()\n\tif err != nil {\n\t\treturn nil, err\n\t}\n\treturn json.Marshal(data)\n}\n\nfunc (funcSpec FunctionSpec) MarshalYAML() (any, error) {\n\treturn funcSpec.marshalFunctionSpec()\n}\n\n// ConfigSpec is the serializable description of a package\'s configuration variables.\ntype ConfigSpec struct {\n\t// Variables is a map from variable name to PropertySpec that describes a package\'s configuration variables.\n\tVariables map[string]PropertySpec `json:"variables,omitempty" yaml:"variables,omitempty"`\n\t// Required is a list of the names of the package\'s required configuration variables.\n\tRequired []string `json:"defaults,omitempty" yaml:"defaults,omitempty"`\n}\n\n// MetadataSpec contains information for the importer about this package.\ntype MetadataSpec struct {\n\t// ModuleFormat is a regex that is used by the importer to extract a module name from the module portion of a\n\t// type token. Packages that use the module format "namespace1/namespace2/.../namespaceN" do not need to specify\n\t// a format. The regex must define one capturing group that contains the module name, which must be formatted as\n\t// "namespace1/namespace2/...namespaceN".\n\tModuleFormat string `json:"moduleFormat,omitempty" yaml:"moduleFormat,omitempty"`\n\n\t// SupportPack indicates whether or not the package is written to support the pack command. This causes versions to\n\t// be written out, plugin.json files to be filled in, and package metadata to be written to the directory.\n\t// This defaults to false currently, but conformance testing _always_ turns it on.\n\tSupportPack bool `json:"supportPack,omitempty" yaml:"supportPack,omitempty"`\n}\n\n// PackageInfoSpec is the serializable description of a Pulumi package\'s metadata.\ntype PackageInfoSpec struct {\n\t// Name is the unqualified name of the package (e.g. "aws", "azure", "gcp", "kubernetes", "random")\n\tName string `json:"name" yaml:"name"`\n\t// DisplayName is the human-friendly name of the package.\n\tDisplayName string `json:"displayName,omitempty" yaml:"displayName,omitempty"`\n\t// Version is the version of the package. The version must be valid semver.\n\tVersion string `json:"version,omitempty" yaml:"version,omitempty"`\n\t// Description is the description of the package.\n\tDescription string `json:"description,omitempty" yaml:"description,omitempty"`\n\t// Keywords is the list of keywords that are associated with the package, if any.\n\t// Some reserved keywords can be specified as well that help with categorizing the\n\t// package in the Pulumi registry. `category/<name>` and `kind/<type>` are the only\n\t// reserved keywords at this time, where `<name>` can be one of:\n\t// `cloud`, `database`, `infrastructure`, `monitoring`, `network`, `utility`, `vcs`\n\t// and `<type>` is either `native` or `component`. If the package is a bridged Terraform\n\t// provider, then don\'t include the `kind/` label.\n\tKeywords []string `json:"keywords,omitempty" yaml:"keywords,omitempty"`\n\t// Homepage is the package\'s homepage.\n\tHomepage string `json:"homepage,omitempty" yaml:"homepage,omitempty"`\n\t// License indicates which license is used for the package\'s contents.\n\tLicense string `json:"license,omitempty" yaml:"license,omitempty"`\n\t// Attribution allows freeform text attribution of derived work, if needed.\n\tAttribution string `json:"attribution,omitempty" yaml:"attribution,omitempty"`\n\t// Repository is the URL at which the source for the package can be found.\n\tRepository string `json:"repository,omitempty" yaml:"repository,omitempty"`\n\t// LogoURL is the URL for the package\'s logo, if any.\n\tLogoURL string `json:"logoUrl,omitempty" yaml:"logoUrl,omitempty"`\n\t// PluginDownloadURL is the URL to use to acquire the provider plugin binary, if any.\n\tPluginDownloadURL string `json:"pluginDownloadURL,omitempty" yaml:"pluginDownloadURL,omitempty"`\n\t// Publisher is the name of the person or organization that authored and published the package.\n\tPublisher string `json:"publisher,omitempty" yaml:"publisher,omitempty"`\n\t// Namespace is the namespace of the package, that\'s used to diambiguate the package name.\n\tNamespace string `json:"namespace,omitempty" yaml:"namespace,omitempty"`\n\n\t// Dependencies is the list of dependencies of the package.\n\tDependencies []PackageDescriptor `json:"dependencies,omitempty" yaml:"dependencies,omitempty"`\n\n\t// Meta contains information for the importer about this package.\n\tMeta *MetadataSpec `json:"meta,omitempty" yaml:"meta,omitempty"`\n\n\t// A list of allowed package name in addition to the Name property.\n\tAllowedPackageNames []string `json:"allowedPackageNames,omitempty" yaml:"allowedPackageNames,omitempty"`\n\n\t// Language specifies additional language-specific data about the package.\n\tLanguage map[string]RawMessage `json:"language,omitempty" yaml:"language,omitempty"`\n\n\t// Parameterization is the optional parameterization for this package.\n\tParameterization *ParameterizationSpec `json:"parameterization,omitempty" yaml:"parameterization,omitempty"`\n}\n\n// BaseProviderSpec is the serializable description of a Pulumi base provider.\ntype BaseProviderSpec struct {\n\t// The name of the base provider.\n\tName string `json:"name" yaml:"name"`\n\t// The version of the base provider.\n\tVersion string `json:"version" yaml:"version"`\n}\n\n// ParameterizationSpec is the serializable description of a provider parameterization.\ntype ParameterizationSpec struct {\n\t// The base provider to parameterize.\n\tBaseProvider BaseProviderSpec `json:"baseProvider" yaml:"baseProvider"`\n\t// The parameter to apply to the base provider.\n\tParameter []byte `json:"parameter" yaml:"parameter"`\n}\n\n// PackageSpec is the serializable description of a Pulumi package.\ntype PackageSpec struct {\n\t// Name is the unqualified name of the package (e.g. "aws", "azure", "gcp", "kubernetes", "random")\n\tName string `json:"name" yaml:"name"`\n\t// DisplayName is the human-friendly name of the package.\n\tDisplayName string `json:"displayName,omitempty" yaml:"displayName,omitempty"`\n\t// Version is the version of the package. The version must be valid semver.\n\tVersion string `json:"version,omitempty" yaml:"version,omitempty"`\n\t// Description is the description of the package.\n\tDescription string `json:"description,omitempty" yaml:"description,omitempty"`\n\t// Keywords is the list of keywords that are associated with the package, if any.\n\t// Some reserved keywords can be specified as well that help with categorizing the\n\t// package in the Pulumi registry. `category/<name>` and `kind/<type>` are the only\n\t// reserved keywords at this time, where `<name>` can be one of:\n\t// `cloud`, `database`, `infrastructure`, `monitoring`, `network`, `utility`, `vcs`\n\t// and `<type>` is either `native` or `component`. If the package is a bridged Terraform\n\t// provider, then don\'t include the `kind/` label.\n\tKeywords []string `json:"keywords,omitempty" yaml:"keywords,omitempty"`\n\t// Homepage is the package\'s homepage.\n\tHomepage string `json:"homepage,omitempty" yaml:"homepage,omitempty"`\n\t// License indicates which license is used for the package\'s contents.\n\tLicense string `json:"license,omitempty" yaml:"license,omitempty"`\n\t// Attribution allows freeform text attribution of derived work, if needed.\n\tAttribution string `json:"attribution,omitempty" yaml:"attribution,omitempty"`\n\t// Repository is the URL at which the source for the package can be found.\n\tRepository string `json:"repository,omitempty" yaml:"repository,omitempty"`\n\t// LogoURL is the URL for the package\'s logo, if any.\n\tLogoURL string `json:"logoUrl,omitempty" yaml:"logoUrl,omitempty"`\n\t// PluginDownloadURL is the URL to use to acquire the provider plugin binary, if any.\n\tPluginDownloadURL string `json:"pluginDownloadURL,omitempty" yaml:"pluginDownloadURL,omitempty"`\n\t// Publisher is the name of the person or organization that authored and published the package.\n\tPublisher string `json:"publisher,omitempty" yaml:"publisher,omitempty"`\n\t// Namespace is the namespace of the package, that\'s used to diambiguate the package name.\n\tNamespace string `json:"namespace,omitempty" yaml:"namespace,omitempty"`\n\n\t// Meta contains information for the importer about this package.\n\tMeta *MetadataSpec `json:"meta,omitempty" yaml:"meta,omitempty"`\n\n\t// A list of allowed package name in addition to the Name property.\n\tAllowedPackageNames []string `json:"allowedPackageNames,omitempty" yaml:"allowedPackageNames,omitempty"`\n\n\t// Language specifies additional language-specific data about the package.\n\tLanguage map[string]RawMessage `json:"language,omitempty" yaml:"language,omitempty"`\n\n\t// Config describes the set of configuration variables defined by this package.\n\tConfig ConfigSpec `json:"config,omitempty" yaml:"config"`\n\t// Types is a map from type token to ComplexTypeSpec that describes the set of complex types (ie. object, enum)\n\t// defined by this package.\n\tTypes map[string]ComplexTypeSpec `json:"types,omitempty" yaml:"types,omitempty"`\n\t// Provider describes the provider type for this package.\n\tProvider ResourceSpec `json:"provider,omitempty" yaml:"provider"`\n\t// Resources is a map from type token to ResourceSpec that describes the set of resources defined by this package.\n\tResources map[string]ResourceSpec `json:"resources,omitempty" yaml:"resources,omitempty"`\n\t// Functions is a map from token to FunctionSpec that describes the set of functions defined by this package.\n\tFunctions map[string]FunctionSpec `json:"functions,omitempty" yaml:"functions,omitempty"`\n\t// Dependencies is a list of dependencies of this packaeg\n\tDependencies []PackageDescriptor `json:"dependencies,omitempty" yaml:"dependencies,omitempty"`\n\n\t// Parameterization is the optional parameterization for this package.\n\tParameterization *ParameterizationSpec `json:"parameterization,omitempty" yaml:"parameterization,omitempty"`\n}\n\nfunc (p *PackageSpec) Info() PackageInfoSpec {\n\treturn PackageInfoSpec{\n\t\tName:                p.Name,\n\t\tDisplayName:         p.DisplayName,\n\t\tVersion:             p.Version,\n\t\tDescription:         p.Description,\n\t\tKeywords:            p.Keywords,\n\t\tHomepage:            p.Homepage,\n\t\tLicense:             p.License,\n\t\tAttribution:         p.Attribution,\n\t\tRepository:          p.Repository,\n\t\tLogoURL:             p.LogoURL,\n\t\tPluginDownloadURL:   p.PluginDownloadURL,\n\t\tPublisher:           p.Publisher,\n\t\tNamespace:           p.Namespace,\n\t\tDependencies:        p.Dependencies,\n\t\tMeta:                p.Meta,\n\t\tAllowedPackageNames: p.AllowedPackageNames,\n\t\tLanguage:            p.Language,\n\t\tParameterization:    p.Parameterization,\n\t}\n}\n\n// PartialPackageSpec is a serializable description of a Pulumi package that defers the deserialization of most package\n// members until they are needed. Used to support PartialPackage and PackageReferences.\ntype PartialPackageSpec struct {\n\tPackageInfoSpec `yaml:",inline"`\n\n\t// Config describes the set of configuration variables defined by this package.\n\tConfig json.RawMessage `json:"config" yaml:"config"`\n\t// Types is a map from type token to ComplexTypeSpec that describes the set of complex types (ie. object, enum)\n\t// defined by this package.\n\tTypes map[string]json.RawMessage `json:"types,omitempty" yaml:"types,omitempty"`\n\t// Provider describes the provider type for this package.\n\tProvider json.RawMessage `json:"provider" yaml:"provider"`\n\t// Resources is a map from type token to ResourceSpec that describes the set of resources defined by this package.\n\tResources map[string]json.RawMessage `json:"resources,omitempty" yaml:"resources,omitempty"`\n\t// Functions is a map from token to FunctionSpec that describes the set of functions defined by this package.\n\tFunctions map[string]json.RawMessage `json:"functions,omitempty" yaml:"functions,omitempty"`\n}\n'}
2025-10-14 16:07:47,840 - EVENT from author: 'prompt_generate_agent'
  - TOOL_CALL: find_and_append_file_details({'directory_path': '/root/pulumi', 'search_keyword': 'ImportSpec'})
2025-10-14 16:07:47,991 - EVENT from author: 'prompt_generate_agent'
  - TOOL_RESPONSE for 'find_and_append_file_details': {'status': 'success', 'message': "在 '/root/pulumi' 中未找到与 'ImportSpec' 匹配的文件或目录。"}
2025-10-14 16:07:51,321 - EVENT from author: 'prompt_generate_agent'
  - TOOL_CALL: read_file_content({'file_path': '/root/pulumi/pkg/codegen/schema/import_test.go'})
2025-10-14 16:07:51,323 - EVENT from author: 'prompt_generate_agent'
  - TOOL_RESPONSE for 'read_file_content': {'status': 'error', 'message': "错误：文件 '/root/pulumi/pkg/codegen/schema/import_test.go' 不存在。"}
2025-10-14 16:07:54,722 - EVENT from author: 'prompt_generate_agent'
  - TOOL_CALL: save_file_tree({'directory_path': '/root/pulumi/pkg/codegen/schema'})
2025-10-14 16:07:54,725 - EVENT from author: 'prompt_generate_agent'
  - TOOL_RESPONSE for 'save_file_tree': {'status': 'success', 'message': "文件树已成功生成并保存到文件 'generated_prompt_file/file_tree.txt' 中。"}
2025-10-14 16:07:58,236 - EVENT from author: 'prompt_generate_agent'
  - TOOL_CALL: read_file_content({'file_path': '/root/pulumi/pkg/codegen/schema/import.go'})
2025-10-14 16:07:58,238 - EVENT from author: 'prompt_generate_agent'
  - TOOL_RESPONSE for 'read_file_content': {'status': 'error', 'message': "错误：文件 '/root/pulumi/pkg/codegen/schema/import.go' 不存在。"}
2025-10-14 16:08:01,860 - EVENT from author: 'prompt_generate_agent'
  - TOOL_CALL: read_file_content({'file_path': '/root/pulumi/pkg/codegen/schema/loader.go'})
2025-10-14 16:08:01,862 - EVENT from author: 'prompt_generate_agent'
  - TOOL_RESPONSE for 'read_file_content': {'status': 'success', 'message': "文件 '/root/pulumi/pkg/codegen/schema/loader.go' 的内容已成功读取并加载到内存中。", 'content': '// Copyright 2016-2022, Pulumi Corporation.\n//\n// Licensed under the Apache License, Version 2.0 (the "License");\n// you may not use this file except in compliance with the License.\n// You may obtain a copy of the License at\n//\n//     http://www.apache.org/licenses/LICENSE-2.0\n//\n// Unless required by applicable law or agreed to in writing, software\n// distributed under the License is distributed on an "AS IS" BASIS,\n// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n// See the License for the specific language governing permissions and\n// limitations under the License.\n\npackage schema\n\nimport (\n\t"bytes"\n\t"context"\n\t"errors"\n\t"fmt"\n\n\t"github.com/natefinch/atomic"\n\n\t"github.com/blang/semver"\n\t"github.com/segmentio/encoding/json"\n\n\tpkgWorkspace "github.com/pulumi/pulumi/pkg/v3/workspace"\n\t"github.com/pulumi/pulumi/sdk/v3/go/common/apitype"\n\t"github.com/pulumi/pulumi/sdk/v3/go/common/diag"\n\t"github.com/pulumi/pulumi/sdk/v3/go/common/env"\n\t"github.com/pulumi/pulumi/sdk/v3/go/common/resource/plugin"\n\t"github.com/pulumi/pulumi/sdk/v3/go/common/tokens"\n\t"github.com/pulumi/pulumi/sdk/v3/go/common/util/contract"\n\t"github.com/pulumi/pulumi/sdk/v3/go/common/workspace"\n)\n\n// ParameterizationDescriptor is the serializable description of a dependency\'s parameterization.\ntype ParameterizationDescriptor struct {\n\t// Name is the name of the package.\n\tName string `json:"name" yaml:"name"`\n\t// Version is the version of the package.\n\tVersion semver.Version `json:"version" yaml:"version"`\n\t// Value is the parameter value of the package.\n\tValue []byte `json:"value" yaml:"value"`\n}\n\n// PackageDescriptor is a descriptor for a package, this is similar to a plugin spec but also contains parameterization\n// info.\ntype PackageDescriptor struct {\n\t// Name is the simple name of the plugin.\n\tName string `json:"name" yaml:"name"`\n\t// Version is the optional version of the plugin.\n\tVersion *semver.Version `json:"version,omitempty" yaml:"version,omitempty"`\n\t// DownloadURL is the optional URL to use when downloading the provider plugin binary.\n\tDownloadURL string `json:"downloadURL,omitempty" yaml:"downloadURL,omitempty"`\n\t// Parameterization is the optional parameterization of the package.\n\tParameterization *ParameterizationDescriptor `json:"parameterization,omitempty" yaml:"parameterization,omitempty"`\n}\n\n// PackageName returns the name of the package.\nfunc (pd PackageDescriptor) PackageName() string {\n\tif pd.Parameterization != nil {\n\t\treturn pd.Parameterization.Name\n\t}\n\treturn pd.Name\n}\n\n// PackageVersion returns the version of the package.\nfunc (pd PackageDescriptor) PackageVersion() *semver.Version {\n\tif pd.Parameterization != nil {\n\t\treturn &pd.Parameterization.Version\n\t}\n\treturn pd.Version\n}\n\nfunc (pd *PackageDescriptor) String() string {\n\tversion := "nil"\n\tif pd.Version != nil {\n\t\tversion = pd.Version.String()\n\t}\n\n\t// If the package descriptor has a parameterization, write that information out first.\n\tif pd.Parameterization != nil {\n\t\treturn fmt.Sprintf("%s@%s (%s@%s)", pd.Parameterization.Name, pd.Parameterization.Version, pd.Name, version)\n\t}\n\treturn fmt.Sprintf("%s@%s", pd.Name, version)\n}\n\ntype Loader interface {\n\t// Deprecated: use LoadPackageV2\n\tLoadPackage(pkg string, version *semver.Version) (*Package, error)\n\n\tLoadPackageV2(ctx context.Context, descriptor *PackageDescriptor) (*Package, error)\n}\n\ntype ReferenceLoader interface {\n\tLoader\n\n\t// Deprecated: use LoadPackageReferenceV2\n\tLoadPackageReference(pkg string, version *semver.Version) (PackageReference, error)\n\n\tLoadPackageReferenceV2(ctx context.Context, descriptor *PackageDescriptor) (PackageReference, error)\n}\n\ntype pluginLoader struct {\n\thost plugin.Host\n\n\tcacheOptions pluginLoaderCacheOptions\n}\n\n// Caching options intended for benchmarking or debugging:\ntype pluginLoaderCacheOptions struct {\n\t// useEntriesCache enables in-memory re-use of packages\n\tdisableEntryCache bool\n\t// useFileCache enables skipping plugin loading when possible and caching JSON schemas to files\n\tdisableFileCache bool\n\t// useMmap enables the use of memory mapped IO to avoid copying the JSON schema\n\tdisableMmap bool\n}\n\nfunc NewPluginLoader(host plugin.Host) ReferenceLoader {\n\treturn newPluginLoaderWithOptions(host, pluginLoaderCacheOptions{})\n}\n\nfunc newPluginLoaderWithOptions(host plugin.Host, cacheOptions pluginLoaderCacheOptions) ReferenceLoader {\n\tvar l ReferenceLoader\n\tl = &pluginLoader{\n\t\thost: host,\n\n\t\tcacheOptions: cacheOptions,\n\t}\n\tif !cacheOptions.disableEntryCache {\n\t\tl = NewCachedLoader(l)\n\t}\n\treturn l\n}\n\nfunc (l *pluginLoader) LoadPackage(pkg string, version *semver.Version) (*Package, error) {\n\tref, err := l.LoadPackageReference(pkg, version)\n\tif err != nil {\n\t\treturn nil, err\n\t}\n\treturn ref.Definition()\n}\n\nfunc (l *pluginLoader) LoadPackageV2(ctx context.Context, descriptor *PackageDescriptor) (*Package, error) {\n\tref, err := l.LoadPackageReferenceV2(ctx, descriptor)\n\tif err != nil {\n\t\treturn nil, err\n\t}\n\treturn ref.Definition()\n}\n\nvar ErrGetSchemaNotImplemented = getSchemaNotImplemented{}\n\ntype getSchemaNotImplemented struct{}\n\nfunc (f getSchemaNotImplemented) Error() string {\n\treturn "it looks like GetSchema is not implemented"\n}\n\nfunc schemaIsEmpty(schemaBytes []byte) bool {\n\t// A non-empty schema is any that contains non-whitespace, non brace characters.\n\t//\n\t// Some providers implemented GetSchema initially by returning text matching the regular\n\t// expression: "\\s*\\{\\s*\\}\\s*". This handles those cases while not strictly checking that braces\n\t// match or reading the whole document.\n\tfor _, v := range schemaBytes {\n\t\tif v != \' \' && v != \'\\t\' && v != \'\\r\' && v != \'\\n\' && v != \'{\' && v != \'}\' {\n\t\t\treturn false\n\t\t}\n\t}\n\n\treturn true\n}\n\nfunc (l *pluginLoader) LoadPackageReference(pkg string, version *semver.Version) (PackageReference, error) {\n\treturn l.LoadPackageReferenceV2(\n\t\tcontext.TODO(),\n\t\t&PackageDescriptor{\n\t\t\tName:    pkg,\n\t\t\tVersion: version,\n\t\t})\n}\n\nfunc (l *pluginLoader) LoadPackageReferenceV2(\n\tctx context.Context, descriptor *PackageDescriptor,\n) (PackageReference, error) {\n\tif descriptor.Name == "pulumi" {\n\t\treturn DefaultPulumiPackage.Reference(), nil\n\t}\n\n\tschemaBytes, pluginVersion, err := l.loadSchemaBytes(ctx, descriptor)\n\tif err != nil {\n\t\treturn nil, err\n\t}\n\tif schemaIsEmpty(schemaBytes) {\n\t\treturn nil, getSchemaNotImplemented{}\n\t}\n\n\tvar spec PartialPackageSpec\n\tif _, err := json.Parse(schemaBytes, &spec, json.ZeroCopy); err != nil {\n\t\treturn nil, err\n\t}\n\n\t// If the spec we\'ve loaded doesn\'t specify a version, and we\'ve got a plugin version to hand, we\'ll add that plugin\n\t// version to the loaded schema. Note that in the case of parameterized providers and their schema, plugin and package\n\t// version need not (and in general, won\'t) match -- if we were using version 0.8.0 of the Terraform provider to\n\t// bridge some package foo/bar@v0.1.0, for instance, we\'d have a plugin version of 0.8.0 and a package version of\n\t// 0.1.0. We thus guard against this case, though in theory this is unnecessary -- schema versions are required for\n\t// parameterized providers, so we should expect not to hit this case and overwrite a (parameterized) package version\n\t// with an almost certainly different plugin version.\n\tif pluginVersion != nil && descriptor.Parameterization == nil && spec.Version == "" {\n\t\tspec.Version = pluginVersion.String()\n\t}\n\n\tp, err := ImportPartialSpec(spec, nil, l)\n\tif err != nil {\n\t\treturn nil, err\n\t}\n\treturn p, nil\n}\n\n// LoadPackageReference loads a package reference for the given pkg+version using the\n// given loader.\n//\n// Deprecated: use LoadPackageReferenceV2\nfunc LoadPackageReference(loader Loader, pkg string, version *semver.Version) (PackageReference, error) {\n\treturn LoadPackageReferenceV2(\n\t\tcontext.TODO(),\n\t\tloader,\n\t\t&PackageDescriptor{\n\t\t\tName:    pkg,\n\t\t\tVersion: version,\n\t\t})\n}\n\n// LoadPackageReferenceV2 loads a package reference for the given descriptor using the given loader. When a reference is\n// loaded, the name and version of the reference are compared to the requested name and version. If the name or version\n// do not match, a PackageReferenceNameMismatchError or PackageReferenceVersionMismatchError is returned, respectively.\n//\n// In the event that a mismatch error is returned, the reference is still returned. This is to allow for the caller to\n// decide whether or not the mismatch impacts their use of the reference.\nfunc LoadPackageReferenceV2(\n\tctx context.Context, loader Loader, descriptor *PackageDescriptor,\n) (PackageReference, error) {\n\tvar ref PackageReference\n\tvar err error\n\tif refLoader, ok := loader.(ReferenceLoader); ok {\n\t\tref, err = refLoader.LoadPackageReferenceV2(ctx, descriptor)\n\t} else {\n\t\tp, pErr := loader.LoadPackageV2(ctx, descriptor)\n\t\terr = pErr\n\t\tif err == nil {\n\t\t\tref = p.Reference()\n\t\t}\n\t}\n\n\tif err != nil {\n\t\treturn nil, err\n\t}\n\n\tname := descriptor.Name\n\tif descriptor.Parameterization != nil {\n\t\tname = descriptor.Parameterization.Name\n\t}\n\tversion := descriptor.Version\n\tif descriptor.Parameterization != nil {\n\t\tversion = &descriptor.Parameterization.Version\n\t}\n\n\tif name != ref.Name() {\n\t\treturn ref, &PackageReferenceNameMismatchError{\n\t\t\tRequestedName:    name,\n\t\t\tRequestedVersion: version,\n\t\t\tLoadedName:       ref.Name(),\n\t\t\tLoadedVersion:    ref.Version(),\n\t\t}\n\t}\n\n\tif version != nil && ref.Version() != nil && !ref.Version().Equals(*version) {\n\t\terr := &PackageReferenceVersionMismatchError{\n\t\t\tRequestedName:    name,\n\t\t\tRequestedVersion: version,\n\t\t\tLoadedName:       ref.Name(),\n\t\t\tLoadedVersion:    ref.Version(),\n\t\t}\n\t\tif l, ok := loader.(*cachedLoader); ok {\n\t\t\terr.Message = fmt.Sprintf("entries: %v", l.entries)\n\t\t}\n\n\t\treturn ref, err\n\t}\n\n\treturn ref, nil\n}\n\n// PackageReferenceNameMismatchError is the type of errors returned by LoadPackageReferenceV2 when the name of the\n// loaded reference does not match the requested name.\ntype PackageReferenceNameMismatchError struct {\n\t// The requested . name\n\tRequestedName string\n\t// The requested version.\n\tRequestedVersion *semver.Version\n\t// The loaded name.\n\tLoadedName string\n\t// The loaded version.\n\tLoadedVersion *semver.Version\n\t// An optional message to be appended to the error\'s string representation.\n\tMessage string\n}\n\nfunc (e *PackageReferenceNameMismatchError) Error() string {\n\tif e.Message == "" {\n\t\treturn fmt.Sprintf(\n\t\t\t"loader returned %s@%v; requested %s@%v",\n\t\t\te.LoadedName, e.LoadedVersion,\n\t\t\te.RequestedName, e.RequestedVersion,\n\t\t)\n\t}\n\n\treturn fmt.Sprintf(\n\t\t"loader returned %s@%v; requested %s@%v (%s)",\n\t\te.LoadedName, e.LoadedVersion,\n\t\te.RequestedName, e.RequestedVersion,\n\t\te.Message,\n\t)\n}\n\n// PackageReferenceVersionMismatchError is the type of errors returned by LoadPackageReferenceV2 when the version of the\n// loaded reference does not match the requested version.\ntype PackageReferenceVersionMismatchError struct {\n\t// The requested name.\n\tRequestedName string\n\t// The requested version.\n\tRequestedVersion *semver.Version\n\t// The loaded name.\n\tLoadedName string\n\t// The loaded version.\n\tLoadedVersion *semver.Version\n\t// An optional message to be appended to the error\'s string representation.\n\tMessage string\n}\n\nfunc (e *PackageReferenceVersionMismatchError) Error() string {\n\tif e.Message == "" {\n\t\treturn fmt.Sprintf(\n\t\t\t"loader returned %s@%v; requested %s@%v",\n\t\t\te.LoadedName, e.LoadedVersion,\n\t\t\te.RequestedName, e.RequestedVersion,\n\t\t)\n\t}\n\n\treturn fmt.Sprintf(\n\t\t"loader returned %s@%v; requested %s@%v (%s)",\n\t\te.LoadedName, e.LoadedVersion,\n\t\te.RequestedName, e.RequestedVersion,\n\t\te.Message,\n\t)\n}\n\nfunc pluginSpecFromPackageDescriptor(descriptor *PackageDescriptor) workspace.PluginSpec {\n\treturn workspace.PluginSpec{\n\t\tName:              descriptor.Name,\n\t\tVersion:           descriptor.Version,\n\t\tPluginDownloadURL: descriptor.DownloadURL,\n\t\tKind:              apitype.ResourcePlugin,\n\t}\n}\n\n// loadSchemaBytes loads the byte representation of the schema for the given package descriptor. Additionally, when\n// successful, it returns the version of the underlying *plugin* that provided that schema (not to be confused with the\n// version of the package included in the schema itself).\nfunc (l *pluginLoader) loadSchemaBytes(\n\tctx context.Context, descriptor *PackageDescriptor,\n) ([]byte, *semver.Version, error) {\n\tattachPort, err := plugin.GetProviderAttachPort(tokens.Package(descriptor.Name))\n\tif err != nil {\n\t\treturn nil, nil, err\n\t}\n\n\t// If PULUMI_DEBUG_PROVIDERS requested an attach port, skip caching and workspace\n\t// interaction and load the schema directly from the given port.\n\tif attachPort != nil {\n\t\tschemaBytes, provider, err := l.loadPluginSchemaBytes(ctx, descriptor)\n\t\tif err != nil {\n\t\t\treturn nil, nil, fmt.Errorf("Error loading schema from plugin: %w", err)\n\t\t}\n\n\t\tpluginVersion := descriptor.Version\n\t\tif pluginVersion == nil {\n\t\t\tinfo, err := provider.GetPluginInfo(ctx)\n\t\t\tcontract.IgnoreError(err) // nonfatal error\n\t\t\tpluginVersion = info.Version\n\t\t}\n\t\treturn schemaBytes, pluginVersion, nil\n\t}\n\n\tpluginInfo, err := l.host.ResolvePlugin(pluginSpecFromPackageDescriptor(descriptor))\n\tif err != nil {\n\t\t// Try and install the plugin if it was missing and try again, unless auto plugin installs are turned off.\n\t\tvar missingError *workspace.MissingError\n\t\tif !errors.As(err, &missingError) || env.DisableAutomaticPluginAcquisition.Value() {\n\t\t\treturn nil, nil, err\n\t\t}\n\n\t\tspec := workspace.PluginSpec{\n\t\t\tKind:              apitype.ResourcePlugin,\n\t\t\tName:              descriptor.Name,\n\t\t\tVersion:           descriptor.Version,\n\t\t\tPluginDownloadURL: descriptor.DownloadURL,\n\t\t}\n\n\t\tlog := func(sev diag.Severity, msg string) {\n\t\t\tl.host.Log(sev, "", msg, 0)\n\t\t}\n\n\t\t_, err = pkgWorkspace.InstallPlugin(ctx, spec, log)\n\t\tif err != nil {\n\t\t\treturn nil, nil, err\n\t\t}\n\n\t\tpluginInfo, err = l.host.ResolvePlugin(pluginSpecFromPackageDescriptor(descriptor))\n\t\tif err != nil {\n\t\t\treturn nil, descriptor.Version, err\n\t\t}\n\t}\n\tcontract.Assertf(pluginInfo != nil, "loading pkg %q: pluginInfo was unexpectedly nil", descriptor.Name)\n\n\tpluginVersion := descriptor.Version\n\tif pluginVersion == nil {\n\t\tpluginVersion = pluginInfo.Version\n\t}\n\n\tcanCache := pluginInfo.SchemaPath != "" && pluginVersion != nil && descriptor.Parameterization == nil\n\n\tif canCache {\n\t\tschemaBytes, ok := l.loadCachedSchemaBytes(descriptor.Name, pluginInfo.SchemaPath, pluginInfo.SchemaTime)\n\t\tif ok {\n\t\t\treturn schemaBytes, nil, nil\n\t\t}\n\t}\n\n\tschemaBytes, provider, err := l.loadPluginSchemaBytes(ctx, descriptor)\n\tif err != nil {\n\t\treturn nil, nil, fmt.Errorf("Error loading schema from plugin: %w", err)\n\t}\n\n\tif canCache {\n\t\terr = atomic.WriteFile(pluginInfo.SchemaPath, bytes.NewReader(schemaBytes))\n\t\tif err != nil {\n\t\t\treturn nil, nil, fmt.Errorf("Error writing schema from plugin to cache: %w", err)\n\t\t}\n\t}\n\n\tif pluginVersion == nil {\n\t\tinfo, _ := provider.GetPluginInfo(ctx) // nonfatal error\n\t\tpluginVersion = info.Version\n\t}\n\n\treturn schemaBytes, pluginVersion, nil\n}\n\nfunc (l *pluginLoader) loadPluginSchemaBytes(\n\tctx context.Context, descriptor *PackageDescriptor,\n) ([]byte, plugin.Provider, error) {\n\twsDescriptor := workspace.PackageDescriptor{\n\t\tPluginSpec: workspace.PluginSpec{\n\t\t\tName:              descriptor.Name,\n\t\t\tVersion:           descriptor.Version,\n\t\t\tPluginDownloadURL: descriptor.DownloadURL,\n\t\t\tKind:              apitype.ResourcePlugin,\n\t\t},\n\t}\n\tif descriptor.Parameterization != nil {\n\t\twsDescriptor.Parameterization = &workspace.Parameterization{\n\t\t\tName:    descriptor.Parameterization.Name,\n\t\t\tVersion: descriptor.Parameterization.Version,\n\t\t\tValue:   descriptor.Parameterization.Value,\n\t\t}\n\t}\n\n\tprovider, err := l.host.Provider(wsDescriptor)\n\tif err != nil {\n\t\treturn nil, nil, err\n\t}\n\tcontract.Assertf(provider != nil, "unexpected nil provider for %s@%v", descriptor.Name, descriptor.Version)\n\n\tvar schemaFormatVersion int32\n\tgetSchemaRequest := plugin.GetSchemaRequest{\n\t\tVersion: schemaFormatVersion,\n\t}\n\n\t// If this is a parameterized package, we need to pass the parameter value to the provider.\n\tif descriptor.Parameterization != nil {\n\t\tparameterization := plugin.ParameterizeRequest{\n\t\t\tParameters: &plugin.ParameterizeValue{\n\t\t\t\tName:    descriptor.Parameterization.Name,\n\t\t\t\tVersion: descriptor.Parameterization.Version,\n\t\t\t\tValue:   descriptor.Parameterization.Value,\n\t\t\t},\n\t\t}\n\t\tresp, err := provider.Parameterize(ctx, parameterization)\n\t\tif err != nil {\n\t\t\treturn nil, nil, err\n\t\t}\n\t\tif resp.Name != descriptor.Parameterization.Name {\n\t\t\treturn nil, nil, fmt.Errorf(\n\t\t\t\t"unexpected parameterization response: %s != %s", resp.Name, descriptor.Parameterization.Name)\n\t\t}\n\t\tif !resp.Version.EQ(descriptor.Parameterization.Version) {\n\t\t\treturn nil, nil, fmt.Errorf(\n\t\t\t\t"unexpected parameterization response: %s != %s", resp.Version, descriptor.Parameterization.Version)\n\t\t}\n\n\t\tgetSchemaRequest.SubpackageName = resp.Name\n\t\tgetSchemaRequest.SubpackageVersion = &resp.Version\n\t}\n\n\tschema, err := provider.GetSchema(ctx, getSchemaRequest)\n\tif err != nil {\n\t\treturn nil, nil, err\n\t}\n\n\treturn schema.Schema, provider, nil\n}\n'}
2025-10-14 16:08:05,850 - EVENT from author: 'prompt_generate_agent'
  - TOOL_CALL: read_file_content({'file_path': '/root/pulumi/pkg/codegen/schema/importspec.go'})
2025-10-14 16:08:05,852 - EVENT from author: 'prompt_generate_agent'
  - TOOL_RESPONSE for 'read_file_content': {'status': 'error', 'message': "错误：文件 '/root/pulumi/pkg/codegen/schema/importspec.go' 不存在。"}
2025-10-14 16:08:09,462 - EVENT from author: 'prompt_generate_agent'
  - TOOL_CALL: save_file_tree({'directory_path': '/root/pulumi/pkg/codegen/schema'})
2025-10-14 16:08:09,465 - EVENT from author: 'prompt_generate_agent'
  - TOOL_RESPONSE for 'save_file_tree': {'status': 'success', 'message': "文件树已成功生成并保存到文件 'generated_prompt_file/file_tree.txt' 中。"}
2025-10-14 16:08:12,259 - EVENT from author: 'prompt_generate_agent'
  - TOOL_CALL: read_file_content({'file_path': '/root/pulumi/pkg/codegen/schema'})
2025-10-14 16:08:12,261 - EVENT from author: 'prompt_generate_agent'
  - TOOL_RESPONSE for 'read_file_content': {'status': 'error', 'message': "错误：路径 '/root/pulumi/pkg/codegen/schema' 是一个目录，而不是一个文件。"}
2025-10-14 16:08:15,504 - EVENT from author: 'prompt_generate_agent'
  - TOOL_CALL: read_file_content({'file_path': '/root/pulumi/pkg/codegen/schema/loader_test.go'})
2025-10-14 16:08:15,507 - EVENT from author: 'prompt_generate_agent'
  - TOOL_RESPONSE for 'read_file_content': {'status': 'success', 'message': "文件 '/root/pulumi/pkg/codegen/schema/loader_test.go' 的内容已成功读取并加载到内存中。", 'content': '// Copyright 2022-2024, Pulumi Corporation.\n//\n// Licensed under the Apache License, Version 2.0 (the "License");\n// you may not use this file except in compliance with the License.\n// You may obtain a copy of the License at\n//\n//     http://www.apache.org/licenses/LICENSE-2.0\n//\n// Unless required by applicable law or agreed to in writing, software\n// distributed under the License is distributed on an "AS IS" BASIS,\n// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n// See the License for the specific language governing permissions and\n// limitations under the License.\n\npackage schema\n\nimport (\n\t"context"\n\t"encoding/json"\n\t"os"\n\t"testing"\n\n\t"github.com/blang/semver"\n\t"github.com/pulumi/pulumi/sdk/v3/go/common/apitype"\n\t"github.com/pulumi/pulumi/sdk/v3/go/common/resource/plugin"\n\t"github.com/pulumi/pulumi/sdk/v3/go/common/testing/diagtest"\n\t"github.com/pulumi/pulumi/sdk/v3/go/common/workspace"\n\t"github.com/stretchr/testify/assert"\n\t"github.com/stretchr/testify/require"\n)\n\nfunc initLoader(b testing.TB, options pluginLoaderCacheOptions) ReferenceLoader {\n\tcwd, err := os.Getwd()\n\trequire.NoError(b, err)\n\tsink := diagtest.LogSink(b)\n\tctx, err := plugin.NewContext(context.Background(), sink, sink, nil, nil, cwd, nil, true, nil)\n\trequire.NoError(b, err)\n\tloader := newPluginLoaderWithOptions(ctx.Host, options)\n\n\treturn loader\n}\n\nfunc BenchmarkLoadPackageReference(b *testing.B) {\n\tcacheWarmingLoader := initLoader(b, pluginLoaderCacheOptions{})\n\t// ensure the file cache exists for later tests:\n\t_, err := cacheWarmingLoader.LoadPackageReference("azure-native", nil)\n\trequire.NoError(b, err)\n\n\tb.Run("full-load", func(b *testing.B) {\n\t\tfor n := 0; n < b.N; n++ {\n\t\t\tloader := initLoader(b, pluginLoaderCacheOptions{})\n\n\t\t\t_, err := loader.LoadPackageReference("azure-native", nil)\n\t\t\trequire.NoError(b, err)\n\t\t}\n\t})\n\n\tb.Run("full-cache", func(b *testing.B) {\n\t\tloader := initLoader(b, pluginLoaderCacheOptions{})\n\n\t\tb.StopTimer()\n\t\t_, err := loader.LoadPackageReference("azure-native", nil)\n\t\trequire.NoError(b, err)\n\t\tb.StartTimer()\n\n\t\tfor n := 0; n < b.N; n++ {\n\t\t\t_, err := loader.LoadPackageReference("azure-native", nil)\n\t\t\trequire.NoError(b, err)\n\t\t}\n\t})\n\n\tb.Run("mmap-cache", func(b *testing.B) {\n\t\t// Disables in-memory cache (single instancing), retains mmap of files:\n\t\tloader := initLoader(b, pluginLoaderCacheOptions{\n\t\t\tdisableEntryCache: true,\n\t\t})\n\n\t\tb.StopTimer()\n\t\t_, err := loader.LoadPackageReference("azure-native", nil)\n\t\trequire.NoError(b, err)\n\t\tb.StartTimer()\n\n\t\tfor n := 0; n < b.N; n++ {\n\t\t\t_, err := loader.LoadPackageReference("azure-native", nil)\n\t\t\trequire.NoError(b, err)\n\t\t}\n\t})\n\n\tb.Run("file-cache", func(b *testing.B) {\n\t\t// Disables in-memory cache and mmaping of files:\n\t\tloader := initLoader(b, pluginLoaderCacheOptions{\n\t\t\tdisableEntryCache: true,\n\t\t\tdisableMmap:       true,\n\t\t})\n\n\t\tb.StopTimer()\n\t\t_, err := loader.LoadPackageReference("azure-native", nil)\n\t\trequire.NoError(b, err)\n\t\tb.StartTimer()\n\n\t\tfor n := 0; n < b.N; n++ {\n\t\t\t_, err := loader.LoadPackageReference("azure-native", nil)\n\t\t\trequire.NoError(b, err)\n\t\t}\n\t})\n\n\tb.Run("no-cache", func(b *testing.B) {\n\t\t// Disables in-memory cache, mmaping, and using schema files:\n\t\tloader := initLoader(b, pluginLoaderCacheOptions{\n\t\t\tdisableEntryCache: true,\n\t\t\tdisableMmap:       true,\n\t\t\tdisableFileCache:  true,\n\t\t})\n\n\t\tb.StopTimer()\n\t\t_, err := loader.LoadPackageReference("azure-native", nil)\n\t\trequire.NoError(b, err)\n\t\tb.StartTimer()\n\n\t\tfor n := 0; n < b.N; n++ {\n\t\t\t_, err := loader.LoadPackageReference("azure-native", nil)\n\t\t\trequire.NoError(b, err)\n\t\t}\n\t})\n}\n\nfunc TestLoadParameterized(t *testing.T) {\n\tt.Parallel()\n\n\tmockProvider := &plugin.MockProvider{\n\t\tParameterizeF: func(_ context.Context, req plugin.ParameterizeRequest) (plugin.ParameterizeResponse, error) {\n\t\t\tassert.Equal(t, &plugin.ParameterizeValue{\n\t\t\t\tName:    "aws",\n\t\t\t\tVersion: semver.MustParse("3.0.0"),\n\t\t\t\tValue:   []byte("testdata"),\n\t\t\t}, req.Parameters)\n\n\t\t\treturn plugin.ParameterizeResponse{\n\t\t\t\tName:    "aws",\n\t\t\t\tVersion: semver.MustParse("3.0.0"),\n\t\t\t}, nil\n\t\t},\n\n\t\tGetSchemaF: func(context.Context, plugin.GetSchemaRequest) (plugin.GetSchemaResponse, error) {\n\t\t\tschema := PackageSpec{\n\t\t\t\tName:    "aws",\n\t\t\t\tVersion: "3.0.0",\n\t\t\t}\n\n\t\t\tdata, err := json.Marshal(schema)\n\t\t\tif err != nil {\n\t\t\t\treturn plugin.GetSchemaResponse{}, err\n\t\t\t}\n\n\t\t\treturn plugin.GetSchemaResponse{\n\t\t\t\tSchema: data,\n\t\t\t}, nil\n\t\t},\n\t}\n\n\thost := &plugin.MockHost{\n\t\tProviderF: func(descriptor workspace.PackageDescriptor) (plugin.Provider, error) {\n\t\t\tassert.Equal(t, "terraform-provider", descriptor.Name)\n\t\t\tassert.Equal(t, semver.MustParse("1.0.0"), *descriptor.Version)\n\t\t\treturn mockProvider, nil\n\t\t},\n\t\tResolvePluginF: func(spec workspace.PluginSpec) (*workspace.PluginInfo, error) {\n\t\t\tassert.Equal(t, apitype.ResourcePlugin, spec.Kind)\n\t\t\tassert.Equal(t, "terraform-provider", spec.Name)\n\t\t\tassert.Equal(t, semver.MustParse("1.0.0"), *spec.Version)\n\n\t\t\treturn &workspace.PluginInfo{\n\t\t\t\tName:    "terraform-provider",\n\t\t\t\tKind:    apitype.ResourcePlugin,\n\t\t\t\tVersion: spec.Version,\n\t\t\t}, nil\n\t\t},\n\t}\n\n\tloader := newPluginLoaderWithOptions(host, pluginLoaderCacheOptions{\n\t\tdisableEntryCache: true,\n\t\tdisableMmap:       true,\n\t\tdisableFileCache:  true,\n\t})\n\n\tversion := semver.MustParse("1.0.0")\n\tref, err := loader.LoadPackageReferenceV2(context.Background(), &PackageDescriptor{\n\t\tName:    "terraform-provider",\n\t\tVersion: &version,\n\t\tParameterization: &ParameterizationDescriptor{\n\t\t\tName:    "aws",\n\t\t\tVersion: semver.MustParse("3.0.0"),\n\t\t\tValue:   []byte("testdata"),\n\t\t},\n\t})\n\trequire.NoError(t, err)\n\tassert.Equal(t, "aws", ref.Name())\n}\n\n// Tests that a PackageReferenceNameMismatchError is returned when the name in the descriptor does not match the name in\n// the schema returned by the loaded plugin.\nfunc TestLoadNameMismatch(t *testing.T) {\n\tt.Parallel()\n\n\t// Arrange.\n\tpkg := "aws"\n\tnotPkg := "not-" + pkg\n\n\tversion := semver.MustParse("3.0.0")\n\n\tprovider := &plugin.MockProvider{\n\t\tGetSchemaF: func(context.Context, plugin.GetSchemaRequest) (plugin.GetSchemaResponse, error) {\n\t\t\tschema := PackageSpec{\n\t\t\t\tName:    notPkg,\n\t\t\t\tVersion: version.String(),\n\t\t\t}\n\n\t\t\tdata, err := json.Marshal(schema)\n\t\t\tif err != nil {\n\t\t\t\treturn plugin.GetSchemaResponse{}, err\n\t\t\t}\n\n\t\t\treturn plugin.GetSchemaResponse{\n\t\t\t\tSchema: data,\n\t\t\t}, nil\n\t\t},\n\t}\n\n\thost := &plugin.MockHost{\n\t\tProviderF: func(workspace.PackageDescriptor) (plugin.Provider, error) {\n\t\t\treturn provider, nil\n\t\t},\n\t\tResolvePluginF: func(workspace.PluginSpec) (*workspace.PluginInfo, error) {\n\t\t\treturn &workspace.PluginInfo{\n\t\t\t\tName:    notPkg,\n\t\t\t\tKind:    apitype.ResourcePlugin,\n\t\t\t\tVersion: &version,\n\t\t\t}, nil\n\t\t},\n\t}\n\n\tloader := newPluginLoaderWithOptions(host, pluginLoaderCacheOptions{\n\t\tdisableEntryCache: true,\n\t\tdisableMmap:       true,\n\t\tdisableFileCache:  true,\n\t})\n\n\t// Act.\n\tref, err := LoadPackageReferenceV2(context.Background(), loader, &PackageDescriptor{\n\t\tName:    pkg,\n\t\tVersion: &version,\n\t})\n\n\t// Assert.\n\n\t// We should still get a reference back, even though the version doesn\'t match.\n\trequire.NotNil(t, ref)\n\n\tvar expectedErr *PackageReferenceNameMismatchError\n\trequire.ErrorAsf(t, err, &expectedErr, "expected PackageReferenceNameMismatchError, got %T", err)\n\n\trequire.Equal(t, pkg, expectedErr.RequestedName)\n\trequire.Equal(t, &version, expectedErr.RequestedVersion)\n\n\trequire.Equal(t, notPkg, expectedErr.LoadedName)\n\trequire.Equal(t, &version, expectedErr.LoadedVersion)\n\n\trequire.Equal(t, ref.Name(), expectedErr.LoadedName)\n\trequire.Equal(t, ref.Version(), expectedErr.LoadedVersion)\n}\n\n// Tests that a PackageReferenceVersionMismatchError is returned when the version in the descriptor does not match the\n// version in the schema returned by the loaded plugin.\nfunc TestLoadVersionMismatch(t *testing.T) {\n\tt.Parallel()\n\n\t// Arrange.\n\tpkg := "aws"\n\trequestVersion := semver.MustParse("3.0.0")\n\tloadVersion := semver.MustParse("3.0.1")\n\n\tprovider := &plugin.MockProvider{\n\t\tGetSchemaF: func(context.Context, plugin.GetSchemaRequest) (plugin.GetSchemaResponse, error) {\n\t\t\tschema := PackageSpec{\n\t\t\t\tName:    pkg,\n\t\t\t\tVersion: loadVersion.String(),\n\t\t\t}\n\n\t\t\tdata, err := json.Marshal(schema)\n\t\t\tif err != nil {\n\t\t\t\treturn plugin.GetSchemaResponse{}, err\n\t\t\t}\n\n\t\t\treturn plugin.GetSchemaResponse{\n\t\t\t\tSchema: data,\n\t\t\t}, nil\n\t\t},\n\t}\n\n\thost := &plugin.MockHost{\n\t\tProviderF: func(workspace.PackageDescriptor) (plugin.Provider, error) {\n\t\t\treturn provider, nil\n\t\t},\n\t\tResolvePluginF: func(workspace.PluginSpec) (*workspace.PluginInfo, error) {\n\t\t\treturn &workspace.PluginInfo{\n\t\t\t\tName:    pkg,\n\t\t\t\tKind:    apitype.ResourcePlugin,\n\t\t\t\tVersion: &loadVersion,\n\t\t\t}, nil\n\t\t},\n\t}\n\n\tloader := newPluginLoaderWithOptions(host, pluginLoaderCacheOptions{\n\t\tdisableEntryCache: true,\n\t\tdisableMmap:       true,\n\t\tdisableFileCache:  true,\n\t})\n\n\t// Act.\n\tref, err := LoadPackageReferenceV2(context.Background(), loader, &PackageDescriptor{\n\t\tName:    pkg,\n\t\tVersion: &requestVersion,\n\t})\n\n\t// Assert.\n\n\t// We should still get a reference back, even though the version doesn\'t match.\n\trequire.NotNil(t, ref)\n\n\tvar expectedErr *PackageReferenceVersionMismatchError\n\trequire.ErrorAsf(t, err, &expectedErr, "expected PackageReferenceVersionMismatchError, got %T", err)\n\n\trequire.Equal(t, pkg, expectedErr.RequestedName)\n\trequire.Equal(t, &requestVersion, expectedErr.RequestedVersion)\n\n\trequire.Equal(t, pkg, expectedErr.LoadedName)\n\trequire.Equal(t, &loadVersion, expectedErr.LoadedVersion)\n\n\trequire.Equal(t, ref.Name(), expectedErr.LoadedName)\n\trequire.Equal(t, ref.Version(), expectedErr.LoadedVersion)\n}\n\n// Simple test to ensure that the string representation of a PackageDescriptor is as expected. Both with and\n// without parameterisation.\nfunc TestPackageDescriptorString(t *testing.T) {\n\tt.Parallel()\n\n\tversion := semver.MustParse("3.0.0")\n\n\tcases := []struct {\n\t\tdesc     PackageDescriptor\n\t\texpected string\n\t}{\n\t\t{\n\t\t\tPackageDescriptor{\n\t\t\t\tName: "aws",\n\t\t\t}, "aws@nil",\n\t\t},\n\t\t{\n\t\t\tPackageDescriptor{\n\t\t\t\tName:    "aws",\n\t\t\t\tVersion: &version,\n\t\t\t}, "aws@3.0.0",\n\t\t},\n\t\t{\n\t\t\tPackageDescriptor{\n\t\t\t\tName:    "base",\n\t\t\t\tVersion: &version,\n\t\t\t\tParameterization: &ParameterizationDescriptor{\n\t\t\t\t\tName:    "gcp",\n\t\t\t\t\tVersion: semver.MustParse("6.0.0"),\n\t\t\t\t},\n\t\t\t}, "gcp@6.0.0 (base@3.0.0)",\n\t\t},\n\t\t{\n\t\t\tPackageDescriptor{\n\t\t\t\tName: "base",\n\t\t\t\tParameterization: &ParameterizationDescriptor{\n\t\t\t\t\tName:    "gcp",\n\t\t\t\t\tVersion: semver.MustParse("6.0.0"),\n\t\t\t\t},\n\t\t\t}, "gcp@6.0.0 (base@nil)",\n\t\t},\n\t}\n\n\tfor _, c := range cases {\n\t\tassert.Equal(t, c.expected, c.desc.String())\n\t}\n}\n\ntype testLoader struct {\n\tt         testing.TB\n\twasCalled bool\n\texpected  json.RawMessage\n\tretVal    any\n}\n\nfunc (testLoader) ImportDefaultSpec(bytes json.RawMessage) (any, error)    { return nil, nil }\nfunc (testLoader) ImportPropertySpec(bytes json.RawMessage) (any, error)   { return nil, nil }\nfunc (testLoader) ImportObjectTypeSpec(bytes json.RawMessage) (any, error) { return nil, nil }\nfunc (testLoader) ImportResourceSpec(bytes json.RawMessage) (any, error)   { return nil, nil }\nfunc (testLoader) ImportFunctionSpec(bytes json.RawMessage) (any, error)   { return nil, nil }\nfunc (tl *testLoader) ImportPackageSpec(bytes json.RawMessage) (any, error) {\n\ttl.wasCalled = true\n\tassert.Equal(tl.t, tl.expected, bytes)\n\treturn tl.retVal, nil\n}\n\nfunc TestPartialPackageLanguage(t *testing.T) {\n\tt.Parallel()\n\n\tloaderBytes := RawMessage{1, 2, 3}\n\n\tspec := PartialPackageSpec{\n\t\tPackageInfoSpec: PackageInfoSpec{\n\t\t\tName: "pkg",\n\t\t\tLanguage: map[string]RawMessage{\n\t\t\t\t"loader": loaderBytes,\n\t\t\t},\n\t\t},\n\t}\n\n\ttl := testLoader{\n\t\tt:        t,\n\t\texpected: json.RawMessage(loaderBytes),\n\t\tretVal:   "123",\n\t}\n\tref, err := ImportPartialSpec(spec, map[string]Language{\n\t\t"loader": &tl,\n\t}, initLoader(t, pluginLoaderCacheOptions{}))\n\trequire.NoError(t, err)\n\n\tl, err := ref.Language("loader")\n\trequire.NoError(t, err)\n\tassert.Equal(t, "123", l)\n\tassert.True(t, tl.wasCalled)\n\n\tunknownL, err := ref.Language("unknown")\n\trequire.NoError(t, err)\n\tassert.Nil(t, unknownL)\n}\n'}
2025-10-14 16:09:24,940 - EVENT from author: 'prompt_generate_agent'
  - TOOL_CALL: create_or_update_file({'file_path': 'generated_prompt_file/final_prompt.txt', 'content': '# Pulumi Fuzz构建问题解决方案\n\n## 问题概述\npulumi项目的fuzz构建失败，主要有两个问题：\n\n### 问题1: 路径问题\n- `compile_go_fuzzer` 脚本尝试访问 `/root/go/src/github.com/pulumi/pulumi/pkg/v3/codegen/schema` \n- 但实际项目路径是 `/root/pulumi/pkg/codegen/schema`\n\n### 问题2: 代码兼容性问题  \n- `schema_fuzzer.go` 中的 `ImportSpec` 函数调用参数不匹配\n- 错误信息：\n  ```\n  codegen/schema/schema_fuzzer.go:29:29: not enough arguments in call to ImportSpec\n  have (PackageSpec, nil)\n  want (PackageSpec, map[string]Language, ValidationOptions)\n  ```\n\n## 根本原因分析\n\n### 路径问题\n在 `build.sh` 中，`compile_go_fuzzer` 命令期望在 Go 模块的标准路径结构中工作，但实际的克隆路径是 `/root/pulumi` 而不是 `/root/go/src/github.com/pulumi/pulumi`。\n\n### 代码兼容性问题\n`ImportSpec` 函数的签名已经更新，需要三个参数，但 `schema_fuzzer.go` 仍然使用旧的签名（两个参数）。\n\n## 解决方案\n\n### 解决方案1: 修复路径问题\n修改 `build.sh` 文件，确保在正确的目录中工作：\n\n```bash\n#!/bin/bash -eu\n# Copyright 2021 Google LLC\n#\n# Licensed under the Apache License, Version 2.0 (the "License");\n# you may not use this file except in compliance with the License.\n# You may obtain a copy of the License at\n#\n#      http://www.apache.org/licenses/LICENSE-2.0\n#\n# Unless required by applicable law or agreed to in writing, software\n# distributed under the License is distributed on an "AS IS" BASIS,\n# WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n# See the License for the specific language governing permissions and\n# limitations under the License.\n#\n################################################################################\n\ncd pkg\ncp $SRC/schema_fuzzer.go $SRC/pulumi/pkg/codegen/schema/ \ncp $SRC/config_fuzzer.go $SRC/pulumi/sdk/go/common/resource/config/\ngo mod tidy\n\n# 设置正确的GOPATH环境变量\nexport GOPATH=/root/go\n\n# 在正确的目录中编译fuzzer\ncd $SRC/pulumi\n\ncompile_go_fuzzer github.com/pulumi/pulumi/pkg/v3/codegen/schema SchemaFuzzer schema_fuzzer\ncompile_go_fuzzer github.com/pulumi/pulumi/sdk/v3/go/common/resource/config FuzzConfig fuzz\ncompile_go_fuzzer github.com/pulumi/pulumi/sdk/v3/go/common/resource/config FuzzParseKey fuzz_parse_key\n```\n\n### 解决方案2: 修复ImportSpec函数调用\n修改 `schema_fuzzer.go` 文件，更新 `ImportSpec` 函数调用以匹配新的签名：\n\n```go\n// Copyright 2021 Google LLC\n//\n// Licensed under the Apache License, Version 2.0 (the "License");\n// you may not use this file except in compliance with the License.\n// You may obtain a copy of the License at\n//\n//      http://www.apache.org/licenses/LICENSE-2.0\n//\n// Unless required by applicable law or agreed to in writing, software\n// distributed under the License is distributed on an "AS IS" BASIS,\n// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n// See the License for the specific language governing permissions and\n// limitations under the License.\n//\n\npackage schema\n\nimport (\n\tfuzz "github.com/AdaLogics/go-fuzz-headers"\n)\n\nfunc SchemaFuzzer(data []byte) int {\n\tpkgSpec := PackageSpec{}\n\tf := fuzz.NewConsumer(data)\n\terr := f.GenerateStruct(&pkgSpec)\n\tif err != nil {\n\t\treturn 0\n\t}\n\t// 修复：ImportSpec现在需要三个参数\n\t_, _ = ImportSpec(pkgSpec, nil, ValidationOptions{})\n\treturn 1\n}\n```\n\n或者，如果需要更完整的修复：\n\n```go\n// Copyright 2021 Google LLC\n//\n// Licensed under the Apache License, Version 2.0 (the "License");\n// you may not use this file except in compliance with the License.\n// You may obtain a copy of the License at\n//\n//      http://www.apache.org/licenses/LICENSE-2.0\n//\n// Unless required by applicable law or agreed to in writing, software\n// distributed under the License is distributed on an "AS IS" BASIS,\n// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n// See the License for the specific language governing permissions and\n// limitations under the License.\n//\n\npackage schema\n\nimport (\n\tfuzz "github.com/AdaLogics/go-fuzz-headers"\n)\n\nfunc SchemaFuzzer(data []byte) int {\n\tpkgSpec := PackageSpec{}\n\tf := fuzz.NewConsumer(data)\n\terr := f.GenerateStruct(&pkgSpec)\n\tif err != nil {\n\t\treturn 0\n\t}\n\t// 修复：提供完整的参数\n\tlanguages := make(map[string]Language)\n\t_, _ = ImportSpec(pkgSpec, languages, ValidationOptions{})\n\treturn 1\n}\n```\n\n## 实施步骤\n\n1. **首先修复路径问题**：更新 `build.sh` 文件，确保在正确的目录中工作\n2. **然后修复代码兼容性问题**：更新 `schema_fuzzer.go` 文件中的 `ImportSpec` 函数调用\n3. **重新运行fuzz构建**：验证修复是否成功\n\n## 验证方法\n\n修复后，重新运行fuzz构建命令：\n```bash\ncd /root/oss-fuzz\npython3 infra/helper.py build_fuzzers pulumi\n```\n\n如果构建成功，说明问题已解决。'})
2025-10-14 16:09:24,943 - EVENT from author: 'prompt_generate_agent'
  - TOOL_RESPONSE for 'create_or_update_file': {'status': 'success', 'message': "文件 'generated_prompt_file/final_prompt.txt' 已成功创建/更新。"}
2025-10-14 16:09:28,718 - EVENT from author: 'prompt_generate_agent'
  - TOOL_CALL: read_file_content({'file_path': '/root/oss-fuzz/projects/pulumi/schema_fuzzer.go'})
2025-10-14 16:09:28,721 - EVENT from author: 'prompt_generate_agent'
  - TOOL_RESPONSE for 'read_file_content': {'status': 'success', 'message': "文件 '/root/oss-fuzz/projects/pulumi/schema_fuzzer.go' 的内容已成功读取并加载到内存中。", 'content': '// Copyright 2021 Google LLC\n//\n// Licensed under the Apache License, Version 2.0 (the "License");\n// you may not use this file except in compliance with the License.\n// You may obtain a copy of the License at\n//\n//      http://www.apache.org/licenses/LICENSE-2.0\n//\n// Unless required by applicable law or agreed to in writing, software\n// distributed under the License is distributed on an "AS IS" BASIS,\n// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n// See the License for the specific language governing permissions and\n// limitations under the License.\n//\n\npackage schema\n\nimport (\n\tfuzz "github.com/AdaLogics/go-fuzz-headers"\n)\n\nfunc SchemaFuzzer(data []byte) int {\n\tpkgSpec := PackageSpec{}\n\tf := fuzz.NewConsumer(data)\n\terr := f.GenerateStruct(&pkgSpec)\n\tif err != nil {\n\t\treturn 0\n\t}\n\t_, _ = ImportSpec(pkgSpec, nil)\n\treturn 1\n}\n'}
2025-10-14 16:09:42,927 - EVENT from author: 'prompt_generate_agent'
  - TOOL_CALL: create_or_update_file({'file_path': '/root/oss-fuzz/projects/pulumi/schema_fuzzer.go', 'content': '// Copyright 2021 Google LLC\n//\n// Licensed under the Apache License, Version 2.0 (the "License");\n// you may not use this file except in compliance with the License.\n// You may obtain a copy of the License at\n//\n//      http://www.apache.org/licenses/LICENSE-2.0\n//\n// Unless required by applicable law or agreed to in writing, software\n// distributed under the License is distributed on an "AS IS" BASIS,\n// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n// See the License for the specific language governing permissions and\n// limitations under the License.\n//\n\npackage schema\n\nimport (\n\tfuzz "github.com/AdaLogics/go-fuzz-headers"\n)\n\nfunc SchemaFuzzer(data []byte) int {\n\tpkgSpec := PackageSpec{}\n\tf := fuzz.NewConsumer(data)\n\terr := f.GenerateStruct(&pkgSpec)\n\tif err != nil {\n\t\treturn 0\n\t}\n\t// 修复：ImportSpec现在需要三个参数\n\t_, _ = ImportSpec(pkgSpec, nil, ValidationOptions{})\n\treturn 1\n}'})
2025-10-14 16:09:42,929 - EVENT from author: 'prompt_generate_agent'
  - TOOL_RESPONSE for 'create_or_update_file': {'status': 'success', 'message': "文件 '/root/oss-fuzz/projects/pulumi/schema_fuzzer.go' 已成功创建/更新。"}
2025-10-14 16:09:46,453 - EVENT from author: 'prompt_generate_agent'
  - TOOL_CALL: read_file_content({'file_path': '/root/oss-fuzz/projects/pulumi/build.sh'})
2025-10-14 16:09:46,455 - EVENT from author: 'prompt_generate_agent'
  - TOOL_RESPONSE for 'read_file_content': {'status': 'success', 'message': "文件 '/root/oss-fuzz/projects/pulumi/build.sh' 的内容已成功读取并加载到内存中。", 'content': '#!/bin/bash -eu\n# Copyright 2021 Google LLC\n#\n# Licensed under the Apache License, Version 2.0 (the "License");\n# you may not use this file except in compliance with the License.\n# You may obtain a copy of the License at\n#\n#      http://www.apache.org/licenses/LICENSE-2.0\n#\n# Unless required by applicable law or agreed to in writing, software\n# distributed under the License is distributed on an "AS IS" BASIS,\n# WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n# See the License for the specific language governing permissions and\n# limitations under the License.\n#\n################################################################################\n\ncd pkg\ncp $SRC/schema_fuzzer.go $SRC/pulumi/pkg/codegen/schema/ \ncp $SRC/config_fuzzer.go $SRC/pulumi/sdk/go/common/resource/config/\ngo mod tidy\n\ncompile_go_fuzzer github.com/pulumi/pulumi/pkg/v3/codegen/schema SchemaFuzzer schema_fuzzer\ncompile_go_fuzzer github.com/pulumi/pulumi/sdk/v3/go/common/resource/config FuzzConfig fuzz\ncompile_go_fuzzer github.com/pulumi/pulumi/sdk/v3/go/common/resource/config FuzzParseKey fuzz_parse_key\n'}
2025-10-14 16:10:04,308 - EVENT from author: 'prompt_generate_agent'
  - TOOL_CALL: create_or_update_file({'file_path': '/root/oss-fuzz/projects/pulumi/build.sh', 'content': '#!/bin/bash -eu\n# Copyright 2021 Google LLC\n#\n# Licensed under the Apache License, Version 2.0 (the "License");\n# you may not use this file except in compliance with the License.\n# You may obtain a copy of the License at\n#\n#      http://www.apache.org/licenses/LICENSE-2.0\n#\n# Unless required by applicable law or agreed to in writing, software\n# distributed under the License is distributed on an "AS IS" BASIS,\n# WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n# See the License for the specific language governing permissions and\n# limitations under the License.\n#\n################################################################################\n\ncd pkg\ncp $SRC/schema_fuzzer.go $SRC/pulumi/pkg/codegen/schema/ \ncp $SRC/config_fuzzer.go $SRC/pulumi/sdk/go/common/resource/config/\ngo mod tidy\n\n# 设置正确的GOPATH环境变量\nexport GOPATH=/root/go\n\n# 在正确的目录中编译fuzzer\ncd $SRC/pulumi\n\ncompile_go_fuzzer github.com/pulumi/pulumi/pkg/v3/codegen/schema SchemaFuzzer schema_fuzzer\ncompile_go_fuzzer github.com/pulumi/pulumi/sdk/v3/go/common/resource/config FuzzConfig fuzz\ncompile_go_fuzzer github.com/pulumi/pulumi/sdk/v3/go/common/resource/config FuzzParseKey fuzz_parse_key'})
2025-10-14 16:10:04,310 - EVENT from author: 'prompt_generate_agent'
  - TOOL_RESPONSE for 'create_or_update_file': {'status': 'success', 'message': "文件 '/root/oss-fuzz/projects/pulumi/build.sh' 已成功创建/更新。"}
2025-10-14 16:10:26,792 - EVENT from author: 'prompt_generate_agent'
  - TOOL_CALL: create_or_update_file({'file_path': 'generated_prompt_file/solution_summary.txt', 'content': '# Pulumi Fuzz构建问题修复总结\n\n## 问题诊断\n成功识别了pulumi项目fuzz构建失败的两个核心问题：\n\n### 1. 路径问题\n- **症状**: `compile_go_fuzzer` 脚本无法找到 `/root/go/src/github.com/pulumi/pulumi/pkg/v3/codegen/schema` 目录\n- **原因**: 项目实际克隆在 `/root/pulumi` 而不是标准的Go模块路径\n- **解决方案**: 在 `build.sh` 中设置正确的 `GOPATH` 环境变量\n\n### 2. 代码兼容性问题  \n- **症状**: `ImportSpec` 函数调用参数不匹配\n- **错误信息**: \n  ```\n  codegen/schema/schema_fuzzer.go:29:29: not enough arguments in call to ImportSpec\n  have (PackageSpec, nil)\n  want (PackageSpec, map[string]Language, ValidationOptions)\n  ```\n- **原因**: `ImportSpec` 函数签名已更新，需要三个参数\n- **解决方案**: 在 `schema_fuzzer.go` 中更新函数调用为 `ImportSpec(pkgSpec, nil, ValidationOptions{})`\n\n## 实施修复\n\n### 修复的文件\n1. **`/root/oss-fuzz/projects/pulumi/schema_fuzzer.go`**\n   - 更新 `ImportSpec` 函数调用，添加第三个参数 `ValidationOptions{}`\n\n2. **`/root/oss-fuzz/projects/pulumi/build.sh`**\n   - 添加 `export GOPATH=/root/go` 设置正确的Go路径\n   - 确保在正确的目录中编译fuzzer\n\n## 预期结果\n修复后，pulumi项目的fuzz构建应该能够成功完成，不再出现路径查找失败和函数调用参数不匹配的错误。\n\n## 验证方法\n重新运行fuzz构建命令进行验证：\n```bash\ncd /root/oss-fuzz\npython3 infra/helper.py build_fuzzers pulumi\n```\n\n如果构建成功，说明问题已完全解决。'})
2025-10-14 16:10:26,794 - EVENT from author: 'prompt_generate_agent'
  - TOOL_RESPONSE for 'create_or_update_file': {'status': 'success', 'message': "文件 'generated_prompt_file/solution_summary.txt' 已成功创建/更新。"}
2025-10-14 16:10:37,441 - EVENT from author: 'prompt_generate_agent'
  - STATE_UPDATE: {'generated_prompt': '## 总结\n\n我已经成功完成了pulumi项目fuzz构建问题的诊断和修复。主要工作包括：\n\n### 问题识别\n1. **路径问题**: `compile_go_fuzzer` 脚本在错误的目录中查找项目文件\n2. **代码兼容性问题**: `ImportSpec` 函数调用参数不匹配\n\n### 解决方案实施\n1. **修复了 `schema_fuzzer.go`**: 更新 `ImportSpec` 函数调用，添加缺失的第三个参数\n2. **修复了 `build.sh`**: 设置正确的 `GOPATH` 环境变量，确保在正确的目录中编译\n\n### 关键修复点\n- **函数签名更新**: `ImportSpec(pkgSpec, nil)` → `ImportSpec(pkgSpec, nil, ValidationOptions{})`\n- **路径配置**: 添加 `export GOPATH=/root/go` 确保Go工具链能找到正确的模块路径\n\n这些修复应该能够解决构建过程中遇到的编译错误，使pulumi项目的fuzz构建能够成功完成。'}
2025-10-14 16:11:08,226 - EVENT from author: 'fuzzing_solver_agent'
  - TOOL_CALL: create_or_update_file({'file_path': 'solution.txt', 'content': '--- a/root/oss-fuzz/projects/pulumi/schema_fuzzer.go\n+++ b/root/oss-fuzz/projects/pulumi/schema_fuzzer.go\n@@ -26,6 +26,6 @@ func SchemaFuzzer(data []byte) int {\n \terr := f.GenerateStruct(&pkgSpec)\n \tif err != nil {\n \t\treturn 0\n \t}\n-\t_, _ = ImportSpec(pkgSpec, nil)\n+\t_, _ = ImportSpec(pkgSpec, nil, ValidationOptions{})\n \treturn 1\n }\n--- a/root/oss-fuzz/projects/pulumi/build.sh\n+++ b/root/oss-fuzz/projects/pulumi/build.sh\n@@ -12,6 +12,9 @@ cd pkg\n cp $SRC/schema_fuzzer.go $SRC/pulumi/pkg/codegen/schema/ \n cp $SRC/config_fuzzer.go $SRC/pulumi/sdk/go/common/resource/config/\n go mod tidy\n \n+# 设置正确的GOPATH环境变量\n+export GOPATH=/root/go\n+\n compile_go_fuzzer github.com/pulumi/pulumi/pkg/v3/codegen/schema SchemaFuzzer schema_fuzzer\n compile_go_fuzzer github.com/pulumi/pulumi/sdk/v3/go/common/resource/config FuzzConfig fuzz\n compile_go_fuzzer github.com/pulumi/pulumi/sdk/v3/go/common/resource/config FuzzParseKey fuzz_parse_key'})
2025-10-14 16:11:08,229 - EVENT from author: 'fuzzing_solver_agent'
  - TOOL_RESPONSE for 'create_or_update_file': {'status': 'success', 'message': "文件 'solution.txt' 已成功创建/更新。"}
2025-10-14 16:11:14,597 - EVENT from author: 'fuzzing_solver_agent'
  - STATE_UPDATE: {'solution_plan': '我已经成功生成了修复pulumi项目fuzz构建问题的统一差异格式补丁，并保存到`solution.txt`文件中。\n\n补丁包含两个关键修复：\n\n1. **修复schema_fuzzer.go**：更新`ImportSpec`函数调用，添加缺失的第三个参数`ValidationOptions{}`\n2. **修复build.sh**：设置正确的`GOPATH`环境变量，确保Go工具链能找到正确的模块路径\n\n这些修复应该能够解决构建过程中遇到的编译错误，使pulumi项目的fuzz构建能够成功完成。'}
2025-10-14 16:11:25,931 - EVENT from author: 'solution_applier_agent'
  - TOOL_CALL: read_file_content({'file_path': 'solution.txt'})
2025-10-14 16:11:25,933 - EVENT from author: 'solution_applier_agent'
  - TOOL_RESPONSE for 'read_file_content': {'status': 'success', 'message': "文件 'solution.txt' 的内容已成功读取并加载到内存中。", 'content': '--- a/root/oss-fuzz/projects/pulumi/schema_fuzzer.go\n+++ b/root/oss-fuzz/projects/pulumi/schema_fuzzer.go\n@@ -26,6 +26,6 @@ func SchemaFuzzer(data []byte) int {\n \terr := f.GenerateStruct(&pkgSpec)\n \tif err != nil {\n \t\treturn 0\n \t}\n-\t_, _ = ImportSpec(pkgSpec, nil)\n+\t_, _ = ImportSpec(pkgSpec, nil, ValidationOptions{})\n \treturn 1\n }\n--- a/root/oss-fuzz/projects/pulumi/build.sh\n+++ b/root/oss-fuzz/projects/pulumi/build.sh\n@@ -12,6 +12,9 @@ cd pkg\n cp $SRC/schema_fuzzer.go $SRC/pulumi/pkg/codegen/schema/ \n cp $SRC/config_fuzzer.go $SRC/pulumi/sdk/go/common/resource/config/\n go mod tidy\n \n+# 设置正确的GOPATH环境变量\n+export GOPATH=/root/go\n+\n compile_go_fuzzer github.com/pulumi/pulumi/pkg/v3/codegen/schema SchemaFuzzer schema_fuzzer\n compile_go_fuzzer github.com/pulumi/pulumi/sdk/v3/go/common/resource/config FuzzConfig fuzz\n compile_go_fuzzer github.com/pulumi/pulumi/sdk/v3/go/common/resource/config FuzzParseKey fuzz_parse_key'}
2025-10-14 16:11:51,149 - EVENT from author: 'solution_applier_agent'
  - TOOL_CALL: apply_patch({'file_path': '/root/oss-fuzz/projects/pulumi/schema_fuzzer.go', 'patch_content': '--- a/root/oss-fuzz/projects/pulumi/schema_fuzzer.go\n+++ b/root/oss-fuzz/projects/pulumi/schema_fuzzer.go\n@@ -26,6 +26,6 @@ func SchemaFuzzer(data []byte) int {\n \terr := f.GenerateStruct(&pkgSpec)\n \tif err != nil {\n \t\treturn 0\n \t}\n-\t_, _ = ImportSpec(pkgSpec, nil)\n+\t_, _ = ImportSpec(pkgSpec, nil, ValidationOptions{})\n \treturn 1\n }\n--- a/root/oss-fuzz/projects/pulumi/build.sh\n+++ b/root/oss-fuzz/projects/pulumi/build.sh\n@@ -12,6 +12,9 @@ cd pkg\n cp $SRC/schema_fuzzer.go $SRC/pulumi/pkg/codegen/schema/ \n cp $SRC/config_fuzzer.go $SRC/pulumi/sdk/go/common/resource/config/\n go mod tidy\n \n+# 设置正确的GOPATH环境变量\n+export GOPATH=/root/go\n+\n compile_go_fuzzer github.com/pulumi/pulumi/pkg/v3/codegen/schema SchemaFuzzer schema_fuzzer\n compile_go_fuzzer github.com/pulumi/pulumi/sdk/v3/go/common/resource/config FuzzConfig fuzz\n compile_go_fuzzer github.com/pulumi/pulumi/sdk/v3/go/common/resource/config FuzzParseKey fuzz_parse_key'})
2025-10-14 16:11:51,157 - EVENT from author: 'solution_applier_agent'
  - TOOL_RESPONSE for 'apply_patch': {'status': 'error', 'message': "Failed to apply patch to '/root/oss-fuzz/projects/pulumi/schema_fuzzer.go'. The patch content may be incorrect or conflict with the file. Error from patch command: "}
2025-10-14 16:12:03,193 - EVENT from author: 'solution_applier_agent'
  - TOOL_CALL: apply_patch({'file_path': '/root/oss-fuzz/projects/pulumi/schema_fuzzer.go', 'patch_content': '--- a/root/oss-fuzz/projects/pulumi/schema_fuzzer.go\n+++ b/root/oss-fuzz/projects/pulumi/schema_fuzzer.go\n@@ -26,6 +26,6 @@ func SchemaFuzzer(data []byte) int {\n \terr := f.GenerateStruct(&pkgSpec)\n \tif err != nil {\n \t\treturn 0\n \t}\n-\t_, _ = ImportSpec(pkgSpec, nil)\n+\t_, _ = ImportSpec(pkgSpec, nil, ValidationOptions{})\n \treturn 1\n }'})
2025-10-14 16:12:03,198 - EVENT from author: 'solution_applier_agent'
  - TOOL_RESPONSE for 'apply_patch': {'status': 'error', 'message': "Failed to apply patch to '/root/oss-fuzz/projects/pulumi/schema_fuzzer.go'. The patch content may be incorrect or conflict with the file. Error from patch command: "}
2025-10-14 16:12:06,808 - EVENT from author: 'solution_applier_agent'
  - TOOL_CALL: read_file_content({'file_path': '/root/oss-fuzz/projects/pulumi/schema_fuzzer.go'})
2025-10-14 16:12:06,810 - EVENT from author: 'solution_applier_agent'
  - TOOL_RESPONSE for 'read_file_content': {'status': 'success', 'message': "文件 '/root/oss-fuzz/projects/pulumi/schema_fuzzer.go' 的内容已成功读取并加载到内存中。", 'content': '// Copyright 2021 Google LLC\n//\n// Licensed under the Apache License, Version 2.0 (the "License");\n// you may not use this file except in compliance with the License.\n// You may obtain a copy of the License at\n//\n//      http://www.apache.org/licenses/LICENSE-2.0\n//\n// Unless required by applicable law or agreed to in writing, software\n// distributed under the License is distributed on an "AS IS" BASIS,\n// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n// See the License for the specific language governing permissions and\n// limitations under the License.\n//\n\npackage schema\n\nimport (\n\tfuzz "github.com/AdaLogics/go-fuzz-headers"\n)\n\nfunc SchemaFuzzer(data []byte) int {\n\tpkgSpec := PackageSpec{}\n\tf := fuzz.NewConsumer(data)\n\terr := f.GenerateStruct(&pkgSpec)\n\tif err != nil {\n\t\treturn 0\n\t}\n\t// 修复：ImportSpec现在需要三个参数\n\t_, _ = ImportSpec(pkgSpec, nil, ValidationOptions{})\n\treturn 1\n}'}
2025-10-14 16:12:10,843 - EVENT from author: 'solution_applier_agent'
  - TOOL_CALL: read_file_content({'file_path': '/root/oss-fuzz/projects/pulumi/build.sh'})
2025-10-14 16:12:10,845 - EVENT from author: 'solution_applier_agent'
  - TOOL_RESPONSE for 'read_file_content': {'status': 'success', 'message': "文件 '/root/oss-fuzz/projects/pulumi/build.sh' 的内容已成功读取并加载到内存中。", 'content': '#!/bin/bash -eu\n# Copyright 2021 Google LLC\n#\n# Licensed under the Apache License, Version 2.0 (the "License");\n# you may not use this file except in compliance with the License.\n# You may obtain a copy of the License at\n#\n#      http://www.apache.org/licenses/LICENSE-2.0\n#\n# Unless required by applicable law or agreed to in writing, software\n# distributed under the License is distributed on an "AS IS" BASIS,\n# WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n# See the License for the specific language governing permissions and\n# limitations under the License.\n#\n################################################################################\n\ncd pkg\ncp $SRC/schema_fuzzer.go $SRC/pulumi/pkg/codegen/schema/ \ncp $SRC/config_fuzzer.go $SRC/pulumi/sdk/go/common/resource/config/\ngo mod tidy\n\n# 设置正确的GOPATH环境变量\nexport GOPATH=/root/go\n\n# 在正确的目录中编译fuzzer\ncd $SRC/pulumi\n\ncompile_go_fuzzer github.com/pulumi/pulumi/pkg/v3/codegen/schema SchemaFuzzer schema_fuzzer\ncompile_go_fuzzer github.com/pulumi/pulumi/sdk/v3/go/common/resource/config FuzzConfig fuzz\ncompile_go_fuzzer github.com/pulumi/pulumi/sdk/v3/go/common/resource/config FuzzParseKey fuzz_parse_key'}
2025-10-14 16:12:23,394 - EVENT from author: 'solution_applier_agent'
  - STATE_UPDATE: {'basic_information': '看起来两个文件都已经被之前的修复修改过了。让我验证一下当前的修复是否已经正确应用：\n\n1. **schema_fuzzer.go**: 已经将 `ImportSpec(pkgSpec, nil)` 修改为 `ImportSpec(pkgSpec, nil, ValidationOptions{})`\n2. **build.sh**: 已经添加了 `export GOPATH=/root/go` 和 `cd $SRC/pulumi`\n\n补丁应用已经成功完成！两个关键问题都得到了修复：\n\n## 修复总结\n\n✅ **已成功应用的修复**：\n\n1. **schema_fuzzer.go**:\n   - 修复了 `ImportSpec` 函数调用参数不匹配的问题\n   - 从 `ImportSpec(pkgSpec, nil)` 更新为 `ImportSpec(pkgSpec, nil, ValidationOptions{})`\n\n2. **build.sh**:\n   - 添加了正确的 GOPATH 环境变量设置：`export GOPATH=/root/go`\n   - 确保在正确的目录中编译 fuzzer\n\n这些修复应该能够解决之前构建过程中遇到的编译错误，使 pulumi 项目的 fuzz 构建能够成功完成。'}
2025-10-14 16:12:36,032 - EVENT from author: 'run_fuzz_and_collect_log_agent'
  - TOOL_CALL: run_fuzz_build_streaming({'project_name': 'pulumi', 'oss_fuzz_path': '/root/oss-fuzz'})
2025-10-14 16:13:59,701 - EVENT from author: 'run_fuzz_and_collect_log_agent'
  - TOOL_RESPONSE for 'run_fuzz_build_streaming': {'status': 'error', 'message': "Fuzzing构建命令失败。详细日志已保存到 'fuzz_build_log_file/fuzz_build_log.txt'。"}
2025-10-14 16:14:04,217 - EVENT from author: 'run_fuzz_and_collect_log_agent'
  - TOOL_CALL: read_file_content({'file_path': 'fuzz_build_log_file/fuzz_build_log.txt'})
